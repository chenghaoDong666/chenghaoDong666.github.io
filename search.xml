<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>spark学习</title>
      <link href="spark-xue-xi/"/>
      <url>spark-xue-xi/</url>
      
        <content type="html"><![CDATA[<p><a href="http://spark.apache.org/docs/latest/api/scala/org/apache/spark/index.html">spark scala api</a></p><p><a href="https://www.scala-lang.org/api/current/">scala api</a></p><p><a href="https://www.runoob.com/scala/scala-tutorial.html">菜鸟教程scala</a></p><p><a href="https://my.oschina.net/joymufeng/blog/863823">scala下划线的使用</a></p><p><a href="https://www.cnblogs.com/wjunge/p/10043079.html">scala=&gt;的使用</a></p><p><a href="https://blog.csdn.net/wz_TXWY/article/details/100860862">scala方法调用方式</a> 其中注意无括号调用法，如果没有参数，可以省略括号</p><p><a href="https://blog.csdn.net/u010256841/article/details/53467905">scala中为什么不建议使用return</a>  简而言之就是更符合函数式编程，且不影响类型推断等</p><p><a href="https://blog.csdn.net/xianpanjia4616/article/details/81143146">scala中的:: , +:, :+, :::, +++, 等操作的含义</a></p><p><code>collect()</code>返回一个包含此RDD中所有元素的数组。</p><p><img src="/spark-xue-xi/image-20201212132112158.png" alt="collect函数"></p><pre class=" language-scala"><code class="language-scala"><span class="token keyword">import</span> org<span class="token punctuation">.</span>apache<span class="token punctuation">.</span>spark<span class="token punctuation">.</span><span class="token punctuation">{</span>SparkConf<span class="token punctuation">,</span> SparkContext<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//SparkConf  Spark应用程序的配置。用于将各种Spark参数设置为键值对。</span><span class="token comment" spellcheck="true">//Spark功能的主入口点。SparkContext表示到Spark集群的连接，可用于在该集群上创建RDDs、累加器和广播变量</span><span class="token keyword">val</span> sparkConf <span class="token operator">=</span> <span class="token keyword">new</span> SparkConf<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>setAppName<span class="token punctuation">(</span><span class="token string">"Association Rule Mining Demo"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//new SparkConf()创建了一个从系统属性和类路径加载默认值的SparkConf对象  </span><span class="token comment" spellcheck="true">//setAppName()为你的应用设置一个名字</span><span class="token keyword">val</span> sc <span class="token operator">=</span> <span class="token keyword">new</span> SparkContext<span class="token punctuation">(</span>sparkConf<span class="token punctuation">)</span><span class="token keyword">val</span> transactions <span class="token operator">=</span> sc<span class="token punctuation">.</span>textFile<span class="token punctuation">(</span>transactionsFileName<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//textFile(path: String, minPartitions: Int = defaultMinPartitions)</span><span class="token comment" spellcheck="true">//从HDFS、本地文件系统(在所有节点上都可用)或hadoop支持的文件系统URI中读取文本文件，并以字符串的RDD形式返回。</span><span class="token comment" spellcheck="true">//minPartitions:生成的RDD的最小分区数</span><span class="token comment" spellcheck="true">//cache():使用默认的存储级别(MEMORY_ONLY)来支持这个RDD。</span><span class="token keyword">val</span> transactionSize <span class="token operator">=</span> transactions<span class="token punctuation">.</span>count<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//count():返回RDD中的元素数量。</span><span class="token keyword">def</span> toList<span class="token punctuation">(</span>transaction<span class="token operator">:</span> <span class="token builtin">String</span><span class="token punctuation">)</span><span class="token operator">:</span> List<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">val</span> list <span class="token operator">=</span> transaction<span class="token punctuation">.</span>trim<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">)</span><span class="token punctuation">.</span>toList list<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//trim():从指定字符串列的两端修剪指定字符。没带参数就是去掉空格</span><span class="token comment" spellcheck="true">//split():将提供的字符序列围绕','匹配项拆分,返回Array[String]</span><span class="token comment" spellcheck="true">//toList():将Array[String]转换为List[Strings]</span><span class="token keyword">def</span> findSortedCombinations<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">(</span>elements<span class="token operator">:</span> List<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">implicit</span> B<span class="token operator">:</span> Ordering<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">:</span> List<span class="token punctuation">[</span>List<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">val</span> result <span class="token operator">=</span> elements<span class="token punctuation">.</span>sorted<span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token punctuation">.</span>toSet<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">.</span>subsets<span class="token punctuation">.</span>map<span class="token punctuation">(</span>_<span class="token punctuation">.</span>toList<span class="token punctuation">)</span><span class="token punctuation">.</span>toList result<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//sorted(B):根据顺序对这个数组进行排序。是稳定排序</span><span class="token comment" spellcheck="true">//toSet[T]():转换为Set</span><span class="token comment" spellcheck="true">//subsets():遍历该集合所有子集的迭代器。</span><span class="token keyword">def</span> removeOneItem<span class="token punctuation">(</span>list<span class="token operator">:</span> List<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token operator">:</span> <span class="token builtin">Int</span><span class="token punctuation">)</span><span class="token operator">:</span> List<span class="token punctuation">[</span><span class="token builtin">String</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>list <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token operator">||</span> list<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> list    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>i <span class="token operator">></span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span>size <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> list    <span class="token punctuation">}</span>    <span class="token keyword">val</span> cloned <span class="token operator">=</span> list<span class="token punctuation">.</span>take<span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">++</span> list<span class="token punctuation">.</span>drop<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>    cloned<span class="token punctuation">}</span><span class="token comment" spellcheck="true">//take(i):选择前i个元素</span><span class="token comment" spellcheck="true">//++：连接两个集合</span><span class="token comment" spellcheck="true">//drpo(i+1):选择除前i+1个元素之外的所有元素。</span><span class="token comment" spellcheck="true">//所以每次去掉了1个元素，如果初始数组传入0，就去掉第一个元素</span><span class="token keyword">val</span> itemsets <span class="token operator">=</span> transactions<span class="token punctuation">.</span>map<span class="token punctuation">(</span>toList<span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>findSortedCombinations<span class="token punctuation">(</span>_<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>x <span class="token keyword">=></span> x<span class="token punctuation">)</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span>_<span class="token punctuation">.</span>size <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>x <span class="token keyword">=></span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">1L</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//map():通过对RDD的所有元素应用一个函数来返回一个新的RDD</span><span class="token comment" spellcheck="true">//flatMap(x => x):</span><span class="token comment" spellcheck="true">//filter(_.size > 0):过滤，过滤掉size=0的,也就是说去掉空集</span><span class="token comment" spellcheck="true">//</span><span class="token keyword">val</span> minSup <span class="token operator">=</span> <span class="token number">0.4</span><span class="token keyword">val</span> combined <span class="token operator">=</span> itemsets<span class="token punctuation">.</span>reduceByKey<span class="token punctuation">(</span>_ <span class="token operator">+</span> _<span class="token punctuation">)</span><span class="token punctuation">.</span>map<span class="token punctuation">(</span>x <span class="token keyword">=></span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>_1<span class="token punctuation">,</span> <span class="token punctuation">(</span>x<span class="token punctuation">.</span>_2<span class="token punctuation">,</span> x<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>toDouble <span class="token operator">/</span> transactionSize<span class="token punctuation">.</span>toDouble<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>_2 <span class="token operator">>=</span> minSup<span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token comment" spellcheck="true">//reduceByKey(_ + _):Key值相同的Value值相加</span><span class="token comment" spellcheck="true">//(key,(value1,value2))</span><span class="token comment" spellcheck="true">//value2>=minSup的过滤一下</span><span class="token keyword">val</span> subitemsets <span class="token operator">=</span> combined<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>itemset <span class="token keyword">=></span> <span class="token punctuation">{</span>    <span class="token keyword">val</span> list <span class="token operator">=</span> itemset<span class="token punctuation">.</span>_1    <span class="token keyword">val</span> frequency <span class="token operator">=</span> itemset<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>_1    <span class="token keyword">val</span> support <span class="token operator">=</span> itemset<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>_2    <span class="token keyword">var</span> result <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token punctuation">(</span>list<span class="token punctuation">,</span> <span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>frequency<span class="token punctuation">,</span> support<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">//((key,("",())))</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>list<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        result    <span class="token punctuation">}</span>     <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">&lt;-</span> <span class="token number">0</span> until list<span class="token punctuation">.</span>size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">val</span> listX <span class="token operator">=</span> removeOneItem<span class="token punctuation">(</span>list<span class="token punctuation">,</span> i<span class="token punctuation">)</span>            <span class="token keyword">val</span> listY <span class="token operator">=</span> list<span class="token punctuation">.</span>diff<span class="token punctuation">(</span>listX<span class="token punctuation">)</span>            result <span class="token operator">++</span><span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token punctuation">(</span>listX<span class="token punctuation">,</span> <span class="token punctuation">(</span>listY<span class="token punctuation">,</span> <span class="token punctuation">(</span>frequency<span class="token punctuation">,</span> support<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>        result    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>cache<span class="token comment" spellcheck="true">//diff(listX):计算此不可变序列和另一个序列之间的多集差异</span><span class="token keyword">val</span> rules <span class="token operator">=</span> subitemsets<span class="token punctuation">.</span>groupByKey<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//groupByKey():和reduceByKey()好像差不多</span><span class="token keyword">val</span> assocRules <span class="token operator">=</span> rules<span class="token punctuation">.</span>map<span class="token punctuation">(</span>in <span class="token keyword">=></span> <span class="token punctuation">{</span>    <span class="token keyword">val</span> listX <span class="token operator">=</span> in<span class="token punctuation">.</span>_1    <span class="token keyword">val</span> listYLists <span class="token operator">=</span> in<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>toList    <span class="token keyword">val</span> countX <span class="token operator">=</span> listYLists<span class="token punctuation">.</span>filter<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_1<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> newListYLists <span class="token operator">=</span> listYLists<span class="token punctuation">.</span>diff<span class="token punctuation">(</span>List<span class="token punctuation">(</span>countX<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newListYLists<span class="token punctuation">.</span>isEmpty<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">val</span> result <span class="token operator">=</span> List<span class="token punctuation">(</span><span class="token punctuation">(</span>List<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> List<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0.0D</span><span class="token punctuation">,</span> <span class="token number">0.0D</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        result    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">val</span> result <span class="token operator">=</span> newListYLists<span class="token punctuation">.</span>map<span class="token punctuation">(</span>t2 <span class="token keyword">=></span> <span class="token punctuation">(</span>listX<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>_1<span class="token punctuation">,</span> t2<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>_1<span class="token punctuation">.</span>toDouble<span class="token operator">/</span>countX<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>_1<span class="token punctuation">.</span>toDouble<span class="token punctuation">,</span>                             t2<span class="token punctuation">.</span>_2<span class="token punctuation">.</span>_2<span class="token punctuation">)</span><span class="token punctuation">)</span>        result    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//最小置信度</span><span class="token keyword">val</span> minConf <span class="token operator">=</span> <span class="token number">0.7</span><span class="token comment" spellcheck="true">//必须要大于置信度</span><span class="token keyword">val</span> finalResult <span class="token operator">=</span> assocRules<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span>x <span class="token keyword">=></span> x<span class="token punctuation">)</span><span class="token punctuation">.</span>filter<span class="token punctuation">(</span>_<span class="token punctuation">.</span>_3 <span class="token operator">>=</span> minConf<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//保存txt文件到输出路径</span>finalResult<span class="token punctuation">.</span>saveAsTextFile<span class="token punctuation">(</span>outputPath<span class="token punctuation">)</span>System<span class="token punctuation">.</span>exit<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>编程软件trick</title>
      <link href="bian-cheng-ruan-jian-trick/"/>
      <url>bian-cheng-ruan-jian-trick/</url>
      
        <content type="html"><![CDATA[<h2 id="jupyter-notebook"><a href="#jupyter-notebook" class="headerlink" title="jupyter notebook"></a>jupyter notebook</h2><p>jupyter notebook使用：<a href="https://zhuanlan.zhihu.com/p/32320214">https://zhuanlan.zhihu.com/p/32320214</a></p><h2 id="pycharm"><a href="#pycharm" class="headerlink" title="pycharm"></a>pycharm</h2><p><a href="https://blog.csdn.net/qq_35473473/article/details/106320708">pycharm配置anaconda环境</a></p><h2 id="spyder"><a href="#spyder" class="headerlink" title="spyder"></a>spyder</h2>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程软件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据集标注和评价指标</title>
      <link href="shu-ju-ji-biao-zhu/"/>
      <url>shu-ju-ji-biao-zhu/</url>
      
        <content type="html"><![CDATA[<h4 id="数据集标注"><a href="#数据集标注" class="headerlink" title="数据集标注"></a>数据集标注</h4><p><a href="https://baike.baidu.com/reference/735928/e1c09zpIxso79ckYFsufW97lGFgDuI-Mkxj7Qi6HYi-OVg50jiLd_3hXeWnola-o_uuaI6DtXtCZNK-NMJpSJxM">开放数据标注工具浅析</a></p><p>包括：labelme labelImg VIA 精灵标注  LabelHub</p><p>ps：ps标注可以选择使用磁性套索或者其他工具，标注完之后就涂色就可以了，自己设计一种颜色，比如urban street scene现在多此采用cityscapes的涂色方案。然后在使用的时候，把不同的rgb映射到类别空间，也就是灰度空间就可以了。一般，rgb是为了更好的结果类别的展示，训练的时候使用的是灰度图像。</p><p><a href="https://github.com/wkentaro/labelme">Labelme</a>     <a href="https://blog.csdn.net/u014061630/article/details/88756644">Labelme教程1</a>      <a href="https://blog.csdn.net/fengxin1995/article/details/80511227">Labelme教程2</a></p><p>start labelme_json_to_dataset 1.json</p><p><a href="https://github.com/lzx1413/LabelImgTool">LabelImgTool</a></p><h4 id="评价指标"><a href="#评价指标" class="headerlink" title="评价指标"></a>评价指标</h4><p><a href="https://blog.csdn.net/qq_28418387/article/details/95662415">F1、IoU等计算方式理解与代码实现</a></p><p>上面这篇文章写得太好了，代码可以拿来直接用</p><p><a href="https://www.cnblogs.com/Trevo/p/11795503.html">评价指标总结和代码实现</a></p><p>最常用的PA和IoU<br>$$<br>PA=\frac{TP+TN}{TP+TN+FP+FN}<br>$$</p><h3 id="SDD-A-Skin-Detection-Dataset-for-Training-and-Assessment-of-Human-Skin-Classifiers"><a href="#SDD-A-Skin-Detection-Dataset-for-Training-and-Assessment-of-Human-Skin-Classifiers" class="headerlink" title="SDD: A Skin Detection Dataset for Training and Assessment of Human Skin Classifiers"></a>SDD: A Skin Detection Dataset for Training and Assessment of Human Skin Classifiers</h3><h4 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h4><p>15年一个皮肤分割数据集</p><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>超过20000张图像  非常精确：<strong>专业图形工具  三元划分</strong>  与SFA比较 <strong>定性且定量</strong>表明更好</p><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p><strong>数据库组织良好</strong>：因此使用时只和方法有关，而和数据集无关</p><p><strong>不同光照和成像条件下捕获</strong></p><p>不像许多其他数据集与半自动GT标签，在SDD，<strong>地面真相注释非常精确，感谢专业图形工具的使用和三元划分的想法。</strong></p><p>使用后者，处理皮肤和非皮肤区域边界上的繁琐点会更加方便和容易。</p><p>对于该数据集的评价，由于单直方图方法的沉默特性，无论是定性还是定量都选择了单直方图方法，结果表明使用SDD方法比SFA更有效。</p><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><h4 id="Skin-Classification"><a href="#Skin-Classification" class="headerlink" title="Skin Classification"></a>Skin Classification</h4><p>例如，有些数据库认为人类嘴唇是皮肤的一部分，而有些数据库则忽略了它。</p><p>目前数据库中的地面真值图像往往太不准确(本文将对此进行说明)。</p><p>事实上，数据集有时是手工注释的，但是，由于这项任务既无聊又费时，它可能被漫不经心地完成。</p><p>在其他数据库中，GT图像使用半自动程序生成，以减少注释时间。然而，ground truth图像还不够精确，甚至可能比人工标记的图像更差。</p><p>在一些数据库中，皮肤像素被标记为非皮肤像素，但它们甚至不靠近皮肤区域，在某些情况下，非皮肤像素被标记为皮肤像素，这在一定程度上降低了性能。</p><p>在一些数据库中，皮肤像素被标记为非皮肤像素，在某些情况下，非皮肤像素被标记为皮肤像素，这在一定程度上降低了性能。</p><p>此外，训练集和测试集的数量和多样性对分类器性能的影响也很明显。然而，在一些工作中，这一因素往往被忽略。有很多作品在报告统计结果时没有考虑到照片集的大小和多样性的影响。一些数据集是在特定的成像和照明条件下编译的。这在评估和培训步骤中都可能出现问题。在评估中，如果数据集不够一般化，算法的结果要么太好，要么太差，都是不现实的。在训练中，使用非通用数据库仅根据特定类型的皮肤像素对系统进行优化，会严重影响算法的性能。有些数据库太小，无法用于各种方法的培训。例如，考虑Jones et al.[17]开发的Bayesian方法，在一种情况下，无论皮肤直方图还是非皮肤直方图，LUT (look-up table)的大小都达到了2×2563个细胞。要对该算法进行适当的训练，需要一个比可能的单元格整个大小大几倍的数据集。在某些情况下，即使数据库相对较大，其大多数映像也会重复多次。此外，一些数据集既不能用于公共用途，也不能免费用于非商业学术用途。基于上述问题，本文的目标是编制一个半理想的应用数据集，可用于训练和评估皮肤检测方法</p><h4 id="Previous-Databases"><a href="#Previous-Databases" class="headerlink" title="Previous Databases"></a>Previous Databases</h4><p>一些皮肤检测数据集最初是为人脸检测、手跟踪和人脸识别问题而开发的。最重要的皮肤数据库组是那些专门为皮肤分类器的训练和评估而设计的，而不是其他生物识别应用。</p><p>康柏是一个相对较老的数据库，其图像质量太低，不再值得信赖。新一代的成像设备已经被开发出来并用于商业用途，它们与以前的设备有很大的不同。另一个问题是康柏没有明确的划分，即不同的作者在测试和评估过程中可能使用不同的图像，这将影响性能。半监督标注，非常不准确</p><p>ECU图像保证了背景场景、光照条件和皮肤类型的多样性。照明条件包括室内照明和室外照明;皮肤类型包括白色，棕色，黄色和黑色皮肤。一些作品已经用这个数据库进行了评估。虽然图像的多样性足以用于评估一般的皮肤检测系统，但数据集的大小还不够大。此外，处理注释还存在一个特殊的问题，即所有图像中，特别是那些质量较低或拥挤的图像中的某些区域，注释并不是一项简单的任务。例如，图3中红色箭头表示的点是毛发周围的像素点，或者其他物体往往会带来额外的困难。这实际上是GTs手工标记方案的错误来源</p><p>基于神经网络皮肤分类器的最佳拓扑和阈值，将UCI和SFA进行了比较，发现在评估皮肤检测器[35]时，SFA的准确性略高于UCI。然而，SFA主要包括半护照图像，不适合用于评估目的。另外，SFA中的GT注释也不一致，即有很多图像没有进行准确的标注。此外，在一些图像中，人脸被2-3像素的厚白色边界包围。这将导致不同颜色空间皮肤簇的构建不准确。图4绘制了GTs对应的SFA图像;它们代表了所有的图像。这个数据集是公开的。</p><h4 id="SDD"><a href="#SDD" class="headerlink" title="SDD"></a>SDD</h4><p>据作者所知，它是文献中引入的用于训练和评估皮肤分类器性能的最大数据库。图像是在不同的光照条件下拍摄的，使用不同的成像设备，从世界各地不同肤色的人。一些图像是在线视频和电影的快照，而一些是从流行的人脸识别/跟踪/检测数据集中获取的静态图像[40-43]。SDD中图像的高度多样性使得它可以用于一般系统的训练和评估，即当一种方法被SDD评估时，结果是可靠的，而当一种方法被SDD训练时，它可以达到其最大的潜在性能。</p><p>如前所述,所有图片中有一些像素要么skinness的有一个问题(比如眉毛和眼睛周围地区,嘴唇和鼻子孔,等等)或者是位于皮肤和non-skin的边界,在这两种情况下,很难区分skinness和一些图片,要花很多的时间来注释。将GT图像划分为3个不重叠区域;皮肤像素、非皮肤像素以及在评估和训练步骤中都被考虑的像素(不关心点)</p><p>用的Photoshop CS5</p><p>$$<br>F1=\frac{2\cdot Recall\cdot Precision}{Recall+Precision}<br>$$</p><p>$$<br>IoU=\frac{tp}{tp+fn+fp}<br>$$</p>]]></content>
      
      
      <categories>
          
          <category> 肤色分级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 肤色分级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tensorflow学习</title>
      <link href="tensorflow-xue-xi/"/>
      <url>tensorflow-xue-xi/</url>
      
        <content type="html"><![CDATA[<p><a href="https://tensorflow.google.cn/api_docs/python/tf?hl=zh_cn">tensorflowAPI</a></p><p><a href="https://keras-cn.readthedocs.io/en/latest/other/callbacks/">keras教程</a></p><p><a href="https://github.com/aymericdamien/TensorFlow-Examples">https://github.com/aymericdamien/TensorFlow-Examples</a></p><p><a href="https://github.com/instillai/TensorFlow-Course">https://github.com/instillai/TensorFlow-Course</a></p><p><a href="https://github.com/sjchoi86/Tensorflow-101">https://github.com/sjchoi86/Tensorflow-101</a></p><p><a href="https://github.com/terryum/TensorFlow_Exercises">https://github.com/terryum/TensorFlow_Exercises</a></p><p>keras是对tensorflow的再封装，是tensorflow的高级api</p><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p>*表示点乘   矩阵乘tf.matmul</p><p><a href="https://www.jianshu.com/p/30b40b504bae">tf.reduce_sum</a>这个博客太强了，把axis彻彻底底讲明白了   <strong>tensorflow的维度情况是NHWC</strong></p><p>本来维度是(2,3) axis=0 完事就变成了(3)   如果keepdims=True，就变成了(1,3)  </p><p>如果axis是一个元组(1,2,3)，就是先加维度1，加完加2，然后加3，如果没有传axis，默认所有的加起来</p><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>cast<span class="token punctuation">(</span>x<span class="token punctuation">,</span>dtype<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#张量数据类型转换</span><span class="token comment" spellcheck="true">#x:要转换的数据</span><span class="token comment" spellcheck="true">#dtype:目标数据类型</span>tf<span class="token punctuation">.</span>shape<span class="token punctuation">(</span>input<span class="token punctuation">,</span>name<span class="token operator">=</span>None<span class="token punctuation">,</span>out_type<span class="token operator">=</span>tf<span class="token punctuation">.</span>int32<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#将矩阵的维度输出为一个维度矩阵</span><span class="token comment" spellcheck="true">#input:张量</span><span class="token comment" spellcheck="true">#name:op的名字，用于tensorboard中</span><span class="token comment" spellcheck="true">#out_type:输出类型</span>tf<span class="token punctuation">.</span>pad<span class="token punctuation">(</span>tensor<span class="token punctuation">,</span> paddings<span class="token punctuation">,</span> mode<span class="token operator">=</span><span class="token string">'CONSTANT'</span><span class="token punctuation">,</span> constant_values<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span> name<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#对张量在各个维度进行填充</span><span class="token comment" spellcheck="true">#tensor:待填充的张量</span><span class="token comment" spellcheck="true">#paddings:对哪个维度进行填充，上下左右填充多少,例如[[1,2],[3,4]],上填充一行，下2行，左3列，右4列</span><span class="token comment" spellcheck="true">#mode 填充方式,有’CONSTANT’'REFLECT''SYMMETRIC'</span><span class="token comment" spellcheck="true">#constant_values:constant填充值</span><span class="token comment" spellcheck="true">#name：操作的名字</span>dataset<span class="token punctuation">.</span>map<span class="token punctuation">(</span>function<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#对dataset中的每一个tf.Tensor执行该函数操作</span>tf<span class="token punctuation">.</span>fill<span class="token punctuation">(</span>dims<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#创建一个充满标量值的张量。</span>tf<span class="token punctuation">.</span>squeeze<span class="token punctuation">(</span>tensor<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#把所有是1的维度都去除，捏一下，挤压一下，把水分挤出来</span></code></pre><h4 id="tf-data-Dataset"><a href="#tf-data-Dataset" class="headerlink" title="tf.data.Dataset"></a>tf.data.Dataset</h4><ol><li>从输入数据创建源数据集。</li><li>应用数据集转换对数据进行预处理。</li><li>遍历数据集并处理元素。</li></ol><p><strong>Source Datasets:</strong></p><p>从列表：</p><pre class=" language-python"><code class="language-python">dataset <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_tensor_slices<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">for</span> element <span class="token keyword">in</span> dataset<span class="token punctuation">:</span>  <span class="token keyword">print</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#tf.Tensor(1, shape=(), dtype=int32)</span><span class="token comment" spellcheck="true">#tf.Tensor(2, shape=(), dtype=int32)</span><span class="token comment" spellcheck="true">#tf.Tensor(3, shape=(), dtype=int32)</span></code></pre><p><strong>as_numpy_iterator</strong></p><p>返回一个迭代器，它将数据集的所有元素转换为numpy。</p><p>使用as_numpy_iterator检查数据集的内容。要查看元素的形状和类型，请直接打印数据集元素，而不是使用as_numpy_iterator</p><p><strong>batch</strong></p><pre class=" language-python"><code class="language-python">batch<span class="token punctuation">(</span>    batch_size<span class="token punctuation">,</span> drop_remainder<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span></code></pre><p>将连续数据组合为batch，drop_remainder表示如果最后的数据不够一批，是否删除</p><p>组合完的数据会多一个额外的维度batch_size,如下：</p><pre class=" language-python"><code class="language-python">dataset <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>range<span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span>dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>batch<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token keyword">for</span> element <span class="token keyword">in</span> dataset<span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#tf.Tensor([0 1 2], shape=(3,), dtype=int64)</span><span class="token comment" spellcheck="true">#tf.Tensor([3 4 5], shape=(3,), dtype=int64)</span><span class="token comment" spellcheck="true">#tf.Tensor([6 7], shape=(2,), dtype=int64)</span></code></pre><p><strong>padded_batch</strong></p><pre class=" language-python"><code class="language-python">padded_batch<span class="token punctuation">(</span>    batch_size<span class="token punctuation">,</span> padded_shapes<span class="token operator">=</span>None<span class="token punctuation">,</span> padding_values<span class="token operator">=</span>None<span class="token punctuation">,</span> drop_remainder<span class="token operator">=</span><span class="token boolean">False</span><span class="token punctuation">)</span></code></pre><p>也是生成batch的，不同的是如果有变长如何填充：</p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true"># Components of nested elements can be padded independently.</span>elements <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">]</span>dataset <span class="token operator">=</span> tf<span class="token punctuation">.</span>data<span class="token punctuation">.</span>Dataset<span class="token punctuation">.</span>from_generator<span class="token punctuation">(</span>    <span class="token keyword">lambda</span><span class="token punctuation">:</span> iter<span class="token punctuation">(</span>elements<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>tf<span class="token punctuation">.</span>int32<span class="token punctuation">,</span> tf<span class="token punctuation">.</span>int32<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"># Pad the first component of the tuple to length 4, and the second</span><span class="token comment" spellcheck="true"># component to the smallest size that fits.</span>dataset <span class="token operator">=</span> dataset<span class="token punctuation">.</span>padded_batch<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span>    padded_shapes<span class="token operator">=</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span>None<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    padding_values<span class="token operator">=</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>list<span class="token punctuation">(</span>dataset<span class="token punctuation">.</span>as_numpy_iterator<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#[(array([[ 1,  2,  3, -1],</span><span class="token comment" spellcheck="true">#         [ 4,  5, -1, -1]], dtype=int32),</span><span class="token comment" spellcheck="true">#  array([[ 10, 100],</span><span class="token comment" spellcheck="true">#         [ 11,  12]], dtype=int32))]</span></code></pre><p><strong>map</strong></p><p>Maps <code>map_func</code> across the elements of this dataset.</p><p><strong>prefetch（buffer_size）</strong></p><p>这允许在处理当前元素时准备后面的元素。这通常会提高延迟和吞吐量，但代价是使用额外的内存来存储预先获取的元素。</p><p><strong>cache</strong></p><p><strong>shuffle</strong> </p><p>随机打乱此数据集的元素。</p><p>这个数据集用buffer_size元素填充一个缓冲区，然后从这个缓冲区随机抽取元素，用新元素替换选中的元素。为了实现完美的洗牌，需要一个大于或等于数据集的完整大小的缓冲区。</p><p>例如，如果数据集包含10,000个元素，但buffer_size被设置为1,000，那么shuffle最初将从缓冲区中的前1,000个元素中随机选择一个元素。一旦一个元素被选中，它在缓冲区中的空间将被下一个元素(即1001 -st)替换，保持缓冲区的1,000个元素。</p><p><strong>prefetch</strong></p><h4 id="流水线"><a href="#流水线" class="headerlink" title="流水线"></a>流水线</h4><p><a href="https://blog.csdn.net/jackhh1/article/details/102763999">https://blog.csdn.net/jackhh1/article/details/102763999</a></p><p>加速器执行训练步骤N时，CPU正在为步骤N+1准备数据，这样可以大大减少CPU和GPU的空闲时间</p><h4 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h4><p><a href="https://keras-cn.readthedocs.io/en/latest/other/callbacks/">https://keras-cn.readthedocs.io/en/latest/other/callbacks/</a></p><h4 id="tf-io"><a href="#tf-io" class="headerlink" title="tf.io"></a>tf.io</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">process_example_paths</span><span class="token punctuation">(</span>example<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#先读取再按照对应格式解码</span>            <span class="token keyword">return</span> <span class="token punctuation">{</span><span class="token string">'feature'</span><span class="token punctuation">:</span> tf<span class="token punctuation">.</span>io<span class="token punctuation">.</span>decode_jpeg<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>io<span class="token punctuation">.</span>read_file<span class="token punctuation">(</span>example<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> channels<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                    <span class="token string">'label'</span><span class="token punctuation">:</span> tf<span class="token punctuation">.</span>io<span class="token punctuation">.</span>decode_png<span class="token punctuation">(</span>tf<span class="token punctuation">.</span>io<span class="token punctuation">.</span>read_file<span class="token punctuation">(</span>example<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> channels<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">#获得如下</span><span class="token comment" spellcheck="true">#tf.Tensor([600 394   3], shape=(3,), dtype=int32)</span><span class="token comment" spellcheck="true">#tf.Tensor([600 394   1], shape=(3,), dtype=int32)</span></code></pre><h3 id="tf-keras"><a href="#tf-keras" class="headerlink" title="tf.keras"></a>tf.keras</h3><h4 id="tf-keras-backend"><a href="#tf-keras-backend" class="headerlink" title="tf.keras.backend"></a>tf.keras.backend</h4><p><a href="https://keras-cn.readthedocs.io/en/latest/backend/">https://keras-cn.readthedocs.io/en/latest/backend/</a></p><p>keras后端API，有Theano和Tensorflow</p><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>backend<span class="token punctuation">.</span>clear_session<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#结束当前的TF计算图，并新建一个。有效的避免模型/层的混乱</span></code></pre><h4 id="tf-keras-models"><a href="#tf-keras-models" class="headerlink" title="tf.keras.models"></a>tf.keras.models</h4><pre class=" language-python"><code class="language-python">tf<span class="token punctuation">.</span>keras<span class="token punctuation">.</span>models<span class="token punctuation">.</span>load_model<span class="token punctuation">(</span>filepath<span class="token punctuation">,</span> custom_objects<span class="token operator">=</span>None<span class="token punctuation">,</span> compile<span class="token operator">=</span><span class="token boolean">True</span><span class="token punctuation">,</span> options<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#可选</span><span class="token comment" spellcheck="true">#compile:布尔值，是否在加载后编译模型</span><span class="token comment" spellcheck="true">#options:可选</span></code></pre><p><a href="https://blog.csdn.net/sjtuxx_lee/article/details/80399514">keras保存和加载模型的方法</a></p><h4 id="tf-keras-utils"><a href="#tf-keras-utils" class="headerlink" title="tf.keras.utils"></a>tf.keras.utils</h4><p>tf.keras.utils.plot_model </p><h4 id="tf-keras-Model"><a href="#tf-keras-Model" class="headerlink" title="tf.keras.Model"></a>tf.keras.Model</h4><p><a href="https://keras-cn.readthedocs.io/en/latest/legacy/models/model/">总体介绍看这个</a></p><p>如果你只是载入模型并利用其predict，可以不用进行compile。在Keras中，compile主要完成损失函数和优化器的一些配置，是为训练服务的。predict会在内部进行符号函数的编译工作（通过调用_make_predict_function生成函数）</p><p><strong>fit</strong></p><p>对于batch_size这个参数，因为我们用的tf.data.Dateset，之前已经制定过批了，不用再指定了</p><h4 id="tf-compat"><a href="#tf-compat" class="headerlink" title="tf.compat"></a>tf.compat</h4><p>提供兼容性功能</p><p>tf.compat.v1.reset_default_graph()   #清除默认图形堆栈并重置全局默认图形。</p><p>具体例子看这个博客<a href="https://blog.csdn.net/duanlianvip/article/details/98626111%EF%BC%8C%E6%88%91%E7%9A%84%E7%90%86%E8%A7%A3%E6%9A%82%E6%97%B6%E5%B0%B1%E6%98%AF%E9%87%8D%E6%96%B0%E5%BC%80%E5%A7%8B%EF%BC%8C%E9%98%B2%E6%AD%A2%E5%9C%A8%E4%BB%A5%E5%89%8D%E7%9A%84%E5%9F%BA%E7%A1%80%E4%B8%8A%E7%94%9F%E6%88%90%E6%96%B0%E8%8A%82%E7%82%B9">https://blog.csdn.net/duanlianvip/article/details/98626111，我的理解暂时就是重新开始，防止在以前的基础上生成新节点</a></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tensorflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网络结构解密</title>
      <link href="wang-luo-jie-gou-jie-mi/"/>
      <url>wang-luo-jie-gou-jie-mi/</url>
      
        <content type="html"><![CDATA[<h2 id="统计学习知识"><a href="#统计学习知识" class="headerlink" title="统计学习知识"></a>统计学习知识</h2><h4 id="正则项"><a href="#正则项" class="headerlink" title="正则项"></a>正则项</h4><p><a href="https://maristie.com/2018/02/Normalization-Standardization-and-Regularization">Differences between Normalization, Standardization and Regularization</a></p><p>翻译成中文是归一化，标准化，正则化，前两个是特征缩放，最后一个是减少过拟合</p><p><strong>贝叶斯学派观点来看，正则项是在模型训练过程中引入了某种模型参数</strong>的<a href="https://zh.wikipedia.org/wiki/%E5%85%88%E9%AA%8C">先验</a>分布[后验由数据得出，先验就是理性推断，不拘束于数据]。</p><p><strong>范数</strong>$L_P-norm$</p><p><img src="/wang-luo-jie-gou-jie-mi/image-20201125202729072.png" alt="Lp范数"></p><p>p=1，<strong>曼哈顿距离</strong>，p=2，<strong>欧式距离</strong>，p为无穷，<strong>无穷范数或最大范数</strong>。</p><p>做正则项时，称为Lp-正则项。L1-正则项也叫<strong>LASSO</strong>正则项，L2-正则项也叫<strong>Tikhonov或Ringe正则项</strong></p><p><a href="https://liam.page/2017/03/30/L1-and-L2-regularizer/">详解</a></p><p>在这里，我们需要关注的最主要是范数的「非负性」。我们刚才讲，损失函数通常是一个有下确界的函数。而这个性质保证了我们可以对损失函数做最优化求解。如果我们要保证目标函数依然可以做最优化求解，那么我们就必须让正则项也有一个下界。非负性无疑提供了这样的下界，而且它是一个下确界——由齐次性保证[当 c=0 时]</p><p>因此，我们说，范数的性质使得它天然地适合作为机器学习的正则项。而范数需要的向量，则是<strong>机器学习的学习目标——参数向量</strong>。</p><p>L0范数表示向量中非零元素的个数 </p><p>我们考虑这样一种普遍的情况，即：预测目标背后的真是规律，可能只和某几个维度的特征有关；而其它维度的特征，要不然作用非常小，要不然纯粹是噪声。在这种情况下，除了这几个维度的特征对应的参数之外，其它维度的参数应该为零。若不然，则当其它维度的特征存在噪音时，模型的行为会发生预期之外的变化，导致过拟合。引入L0范数</p><p>L0范数不好，又引入L1范数，L1范数也可以在梯度更新时使得参数趋于0.</p><p>L1使得参数稀疏化，L2使得参数稠密的趋近于0</p><p><img src="/wang-luo-jie-gou-jie-mi/image-20201125205147790.png" alt="稀疏和稠密的原因"></p><p><strong>提前停止</strong></p><p>提前停止可看做是<strong>时间维度上的正则化</strong>。直觉上，随着迭代次数的增加，如梯度下降这样的训练算法倾向于学习愈加复杂的模型。在实践维度上进行正则化有助于控制模型复杂度，提升泛化能力。在实践中，<strong>提前停止一般是在训练集上进行训练，而后在统计上独立的验证集上进行评估；当模型在验证集上的性能不在提升时，就提前停止训练</strong>。最后，可在测试集上对模型性能做最后测试。</p><p><a href="https://alisure.github.io/2018/04/14/ML/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E6%98%93%E6%B7%B7%E6%A6%82%E5%BF%B5%E4%B9%8B%E7%BB%93%E6%9E%84%E9%A3%8E%E9%99%A9%E4%B8%8E%E7%BB%8F%E9%AA%8C%E9%A3%8E%E9%99%A9/#:~:text=%E7%BB%93%E6%9E%84%E9%A3%8E%E9%99%A9(Structural%20Risk)%EF%BC%9A,%EF%BC%88%E4%BE%8B%E5%A6%82%E6%AD%A3%E5%88%99%E5%8C%96%E9%97%AE%E9%A2%98%EF%BC%89%E3%80%82">期望风险、经验风险、结构风险 简洁</a></p><h4 id="偏差-方差分解"><a href="#偏差-方差分解" class="headerlink" title="偏差-方差分解"></a>偏差-方差分解</h4><p><a href="https://liam.page/2017/03/25/bias-variance-tradeoff/">详解</a></p><p>误差来源有三种：随机误差、偏差和方差</p><p>随机误差是高斯白噪声</p><p>偏差bias描述的是通过学习拟合出来的结果之期望，与真实规律之间的差距，记作$Bias(X)=E[\hat{f}(X)]-f(X)$</p><p>方差variance即是统计学中的定义，描述的是通过学习拟合出来的结果自身的不稳定性，记作$Var(X)=E[(\hat{f}(X)-E[\hat{}f(X)])^2]$</p><p>均方误差可以分解为:$Bias^2+Variance+Random Error$</p><img src="/wang-luo-jie-gou-jie-mi/image-20201125210219206.png" alt="直观图示" style="zoom:67%;"><h4 id="VC维"><a href="#VC维" class="headerlink" title="VC维"></a>VC维</h4><p><a href="https://www.jianshu.com/p/903e35e1c95a">期望风险、经验风险、结构风险2深入</a></p><p>损失函数：度量模型一次预测的好坏</p><p>风险函数：度量平均意义下的模型预测好坏</p><h4 id="对数损失函数"><a href="#对数损失函数" class="headerlink" title="对数损失函数"></a>对数损失函数</h4><p><img src="/wang-luo-jie-gou-jie-mi/image-20201125152106078.png" alt="对数损失函数"></p><p>确实是一致的，只要理解了交叉熵损失中的预测概率q(i)=p(y^i|x)</p><p><strong>结构风险本质</strong></p><p>结构风险是对经验风险模型复杂度的惩罚</p><p><strong>结构化风险（正则项）其实是加入了模型参数分布的先验知识</strong>，也就是贝叶斯学派为了将模型往人们期望的地方去发展，继而加入了先验分布，由于是人为的先验，因此也就是一个规则项（这也就是正则项名称的由来）。这样一来，风险函数将进一步考虑了被估计量的先验概率分布</p><p><strong>统计学习方法=模型+策略+算法</strong></p><p>由决策函数表示的模型为非概率模型，由条件概率表示的模型为概率模型。</p><p><strong>当模型是条件概率分布、损失函数是对数损失函数、模型复杂度由模型的先验概率表示时，结构风险最小化就等价于最大后验概率估计。</strong></p><p><strong>当模型是条件概率分布，损失函数是对数损失函数时，经验风险最小化就等价于极大似然估计</strong></p><h2 id="网络细节"><a href="#网络细节" class="headerlink" title="网络细节"></a>网络细节</h2><h3 id="交叉熵损失函数"><a href="#交叉熵损失函数" class="headerlink" title="交叉熵损失函数"></a>交叉熵损失函数</h3><p><a href="https://blog.csdn.net/b1055077005/article/details/100152102">Cross entropy</a></p><p><strong>信息奠基人香农（Shannon）认为“信息是用来消除随机不确定性的东西”。也就是说衡量信息量大小就看这个信息消除不确定性的程度。</strong></p><p>一件事情概率越大，现在发生的不确定性就越小；概率越小，现在要发生的不确定性就越大，发生后消除的不确定性就越多，信息量就越大。一件事情发生后概率就是1，正常的概率是$P(x)$，消除的不确定性是$1-P(x)$</p><p><strong>所以信息量的大小与信息发生的概率成反比。</strong></p><p>$I(x)=-log(P(x))$</p><p><strong>信息熵是信息量的期望，信息源的综合不确定性</strong></p><p><a href="https://www.jianshu.com/p/43318a3dc715">相对熵</a>    <strong>KL散度衡量两个概率分布之间的差异,其实就是两个分布的熵的差值，也就是到底损失了多少信息</strong><br>$$<br>D_{KL}(p||q)=\sum_{i=1}^Np(x_{i})\cdot (logp(x_i)-logq(x_i))\<br>=E[logp(x)-logq(x)]\<br>=\sum_{i=1}^Np(x_{i})\cdot log\frac{p(x_i)}{q(x_i)}\<br>\quad \quad \quad \quad \quad=\sum_{i=1}^Np(x_{i})logp(x_i)-\sum_{i=1}^Np(x_i)logq(x_i))\<br>=-H(x)+cross_entropy<br>$$<br>p是真实分布，q是预测分布,第一行为啥是$p(x_i)$？<strong>后面的是他们的信息量，用它们的概率分布，但实际算期望的时候还是要看真实的概率。</strong>信息量和概率还是要分开看，对每一个条目，算他们信息量的不同，但实际的概率每个x出现的概率还是真实概率</p><p>实际KL散度算的是<strong>预测分布减去真实分布的熵</strong></p><p><strong>交叉熵,第四行和第五行显示了交叉熵，因为实际训练的时候标签确定，所以H(x)是固定的，交叉熵可以替代KL散度</strong></p><h3 id="带动量的随机梯度下降"><a href="#带动量的随机梯度下降" class="headerlink" title="带动量的随机梯度下降"></a>带动量的随机梯度下降</h3><h3 id="卷积核"><a href="#卷积核" class="headerlink" title="卷积核"></a>卷积核</h3><p>$$<br>\frac{n+2p-f}{s}+1 \<br>D2=K(filters num)<br>$$</p><p>一般p=0,s=1的话，就是n-f+1，对于池化，一般默认f=s</p><h4 id="转置卷积"><a href="#转置卷积" class="headerlink" title="转置卷积"></a>转置卷积</h4><p><a href="https://blog.csdn.net/dugudaibo/article/details/83109814">参考的本篇文章</a></p><p>也叫反卷积/分数步长卷积</p><p>虽然在一些文章中将反卷积与转置卷积认为是等价的，但是 <strong>[1] 中的作者表示他们反对使用反卷积来表示转置卷积</strong>，他们的依据是在<strong>数学中反卷积被定义为卷积的逆</strong>，这<strong>实际上与转置卷积是不相同的。所以在下面的内容，我都是用转置卷积这个名词</strong>。</p><p>我们平时<strong>所接触的卷积其实是滤波</strong>，不是<strong>真正的数学定义上的卷积</strong>。</p><p><img src="/wang-luo-jie-gou-jie-mi/image-20201209205446747.png" alt="步长为2的卷积"></p><p>步长为2的卷积可以<strong>看做步长为1的卷积结果的S=2的采样</strong>，因此可以认为是<strong>下采样</strong>的一种。</p><h3 id="Batch-Normalization"><a href="#Batch-Normalization" class="headerlink" title="Batch Normalization"></a>Batch Normalization</h3><p><a href="https://www.cnblogs.com/guoyaohua/p/8724433.html">一篇比较好的文章</a></p><h2 id="CRF-Loss"><a href="#CRF-Loss" class="headerlink" title="CRF Loss"></a>CRF Loss</h2><h3 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h3><p>On Regularized Losses for Weakly-supervised CNN Segmentation Meng</p><p>18ECCV</p><h3 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h3><p>keywords:<a href="https://zh.wikipedia.org/zh-hans/%E6%AD%A3%E5%88%99%E5%8C%96_(%E6%95%B0%E5%AD%A6)#:~:text=%E5%9C%A8%E6%95%B0%E5%AD%A6%E4%B8%8E%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%A7%91%E5%AD%A6,%E5%8A%A0%E5%9C%A8%E7%9B%AE%E6%A0%87%E5%87%BD%E6%95%B0%E5%BD%93%E4%B8%AD%E3%80%82">Regularization</a>  Semi-supervised Learning CNN Segmentation</p><h2 id="DenseNet"><a href="#DenseNet" class="headerlink" title="DenseNet"></a>DenseNet</h2><p><a href="https://blog.csdn.net/u014380165/article/details/75142664">https://blog.csdn.net/u014380165/article/details/75142664</a></p><p><a href="https://zhuanlan.zhihu.com/p/43057737">https://zhuanlan.zhihu.com/p/43057737</a></p><h2 id="Inception"><a href="#Inception" class="headerlink" title="Inception"></a>Inception</h2><p><a href="https://zhuanlan.zhihu.com/p/36878362">https://zhuanlan.zhihu.com/p/36878362</a></p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 网络结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人像肤色检测-2</title>
      <link href="ren-xiang-pi-fu-jian-ce-2/"/>
      <url>ren-xiang-pi-fu-jian-ce-2/</url>
      
        <content type="html"><![CDATA[<h3 id="Fair-comparison-of-skin-detection-approaches-on-publicly-available-datasets"><a href="#Fair-comparison-of-skin-detection-approaches-on-publicly-available-datasets" class="headerlink" title="Fair comparison of skin detection approaches on publicly available datasets"></a>Fair comparison of skin detection approaches on publicly available datasets</h3><h4 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h4><p>年份：2020</p><p>期刊：EXPERT SYSTEMS WITH APPLICATIONS  JCR分区Q1</p><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>提出了一个公平比较方法，使用几个不同的数据集</p><p>主要贡献：</p><ol><li>肤色检测方法详尽介绍和一个公平比较方法</li><li>数据集收集和检查</li><li>一个评估和结合不同皮肤检测方法的框架</li><li>集成</li></ol><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>DeepLabv3 +,根据我们的实验是表现最好的独立方法</p><p>预训练、微调和集成都是有效的</p><p><strong>现在皮肤分割的最大问题就是没有数据集，建议收集一个不同地区的人的大数据集</strong></p><p>皮肤颜色检测器-&gt;颜色恒常性的预处理-&gt;形态学算子的后处理</p><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>用于区分皮肤和非皮肤像素的有用特征是像素颜色;然而，在不同光照、不同种族和不同采集设备下获得肤色一致性是一项非常具有挑战性的任务。此外，皮肤检测作为其他应用程序的初步步骤，需要计算效率高，不受几何变换、局部遮挡或姿态/面部表情变化的影响，对复杂或伪皮肤背景不敏感，对采集设备的质量具有鲁棒性。</p><p>较近的综述就这三篇  和另外两篇比，这篇主要提供公平比较方法</p><p>现有的最近的深度学习：</p><ul><li>Patch-wise skin segmentation of human body parts via deep neural networks 15 JEI</li><li>Combining Convolutional and Recurrent Neural Networks for Human Skin Detection 17 SPL</li><li>Human Skin Segmentation Using Fully Convolutional Neural Networks 18GCCE</li></ul><h4 id="Skin-detection-approaches"><a href="#Skin-detection-approaches" class="headerlink" title="Skin detection approaches"></a>Skin detection approaches</h4><p>影响因素：</p><ol><li>Human characteristics as ethnicity and age</li><li>Acquisition conditions</li><li>Skin painting</li><li>Complex background</li></ol><p>皮肤检测方法分类：</p><ol><li>考虑是否存在预处理步骤，如色彩校正和照明取消或动态适应，以减少不同获取条件的影响</li><li>考虑用于像素分类的颜色空间 A survey of skin-color modeling and detection methods 07PR                                                         <strong>basic models</strong> (i.e. RGB, normalized RGB), <strong>perceptual models</strong> (i.e. HIS, HSV) <strong>perceptual uniform models</strong> (i.e. CIE-Lab, CIE-Luv) and <strong>orthogonal models</strong> (i.e. YCbCr, YIQ) with the finding that orthogonal models are characterized by a reduced redundancy/correlation among channels, therefore they are the most suited for skin detection</li><li>Examining the problem formulation：图像分割出皮肤存在的区域/基于分隔和分类像素而不考虑邻居/基于像素      基于区域的论文很少，最近的一些卷积神经网络也可以看做基于分割这一类</li><li>执行像素分类的不同方法。1基于规则 2基于使用参数化或非参数化方法的机器学习方法估计颜色分布</li><li>机器学习分类器的不同方法  8种</li></ol><p>最近的两个主方向：</p><ul><li>对于一些应用，背景很容易区分，简单的基于规则的方法就可以，这种往往作为别的复杂任务的一个步骤；然后列举了一系列方法 15年名为SKN的新颜色空间</li><li>神经网络的</li></ul><p>12种基本方法：</p><ul><li>Statistical color models with application to skin detection 2002IJCV   GMM Bayes</li><li>Detector adaptation by maximising agreement between independent data sources 2007CVPR SPL 基于像素</li><li>Cheddad</li><li>Chen</li><li>SA1 SA2 SA3</li><li>DYC</li><li>SegNet</li><li>U-Net</li><li>DeepLab Deeplabv3+  ResNet50预训练 batch size32 学习率0.001 最大epoch30</li></ul><p><strong>重点看TABLE1</strong></p><h4 id="Skin-detection-evaluation-Datasets-and-performance-indicators"><a href="#Skin-detection-evaluation-Datasets-and-performance-indicators" class="headerlink" title="Skin detection evaluation: Datasets and performance indicators"></a>Skin detection evaluation: Datasets and performance indicators</h4><p><strong>重点看TABLE2</strong></p><p>SDD 2015 21000张 精确 未开源</p><p>HGR 2014 1558张  手势图片和皮肤mask  精确 开源</p><p>SFA 2013 1118 张 中等精度 开源</p><p>VDM 2013 285张 精确 人类活动识别+光照广泛 开源</p><p>Pratheepan 2012 78张 精确 简单背景+复杂背景 开源</p><p>Feeval 2009 8991张 不精确质量低但多 开源</p><p>Schmugge 2007 845张 精确 三类 开源</p><p>ECU 2005 4000张 精确 未开源</p><h4 id="A-fair-experimental-comparison"><a href="#A-fair-experimental-comparison" class="headerlink" title="A fair experimental comparison"></a>A fair experimental comparison</h4><p><strong>重点看TABLE3、4</strong></p><h3 id="A-survey-on-skin-detection-in-colored-images"><a href="#A-survey-on-skin-detection-in-colored-images" class="headerlink" title="A survey on skin detection in colored images"></a>A survey on skin detection in colored images</h3><h4 id="Info-1"><a href="#Info-1" class="headerlink" title="Info"></a>Info</h4><p>年份：2018</p><p>期刊：ARTIFICIAL INTELLIGENCE REVIEW JCR分区Q1</p><h3 id="A-Comprehensive-Survey-on-Human-Skin-Detection"><a href="#A-Comprehensive-Survey-on-Human-Skin-Detection" class="headerlink" title="A Comprehensive Survey on Human Skin Detection"></a>A Comprehensive Survey on Human Skin Detection</h3><h4 id="Info-2"><a href="#Info-2" class="headerlink" title="Info"></a>Info</h4><p>2016 IJIGSP</p>]]></content>
      
      
      <categories>
          
          <category> 肤色分级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 肤色分级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Semantic Segmentation</title>
      <link href="semantic-segmentation/"/>
      <url>semantic-segmentation/</url>
      
        <content type="html"><![CDATA[<h4 id="综述"><a href="#综述" class="headerlink" title="综述"></a>综述</h4><p><a href="https://cloud.tencent.com/developer/article/1589733">https://cloud.tencent.com/developer/article/1589733</a></p><p><a href="https://blog.csdn.net/ShuqiaoS/article/details/87360693">https://blog.csdn.net/ShuqiaoS/article/details/87360693</a></p><h3 id="Fully-Convolutional-Networks-for-Semantic-Segmentation"><a href="#Fully-Convolutional-Networks-for-Semantic-Segmentation" class="headerlink" title="Fully Convolutional Networks for Semantic Segmentation"></a>Fully Convolutional Networks for Semantic Segmentation</h3><p>CSDN教程：<a href="https://blog.csdn.net/qq_36269513/article/details/80420363">https://blog.csdn.net/qq_36269513/article/details/80420363</a></p><h4 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h4><p>15 CVPR 17TPAMI</p><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><ol><li>构建全卷积网络，接受任意大小输入</li><li>将现代分类网络AlexNet、VGGNet、GoogLeNet改造为FCN，并微调</li><li>一个skip结构，结合不同深度层结果</li><li>增大数据尺寸的反卷积deconv层。能够输出精细的结果</li></ol><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><ul><li>FCN可解决许多像素级任务  </li><li>代码在Caffe中开源 在Caffe Model Zoo中可获取</li><li>转移预训练分类器权重+fusing不同层表达+整个图端到端-&gt;极大提高准确率</li></ul><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>卷积网不仅全图式的分类上有所提高 ,也在结构化输出的局部任务上取得了进步。包括在目标检测边界框  、部分和关键点预测和局部通信 的进步。从粗推理到精推理的下一步自然是对每个像素进行预测。</p><p>没有复杂的预处理和后处理，包括超像素等</p><h3 id="UNet"><a href="#UNet" class="headerlink" title="UNet"></a>UNet</h3><p><a href="https://www.cnblogs.com/PythonLearner/p/14041874.html">UNet详解</a>  最常用….最简单…  一种<strong>U型的网络结构来获取上下文的信息和位置信息</strong></p><p>Crop操作是如何进行的？</p><p><strong>前半部分</strong>是<strong>特征提取</strong>部分，<strong>后半部分</strong>是<strong>上采样</strong>,有些文献也把这种结构叫做<strong>编码器-解码器</strong>结构。</p><p>copy and crop：在论文中叫拼接，在UNet有四个拼接操作。如上图所示：有人也叫Skip connect,这一操作的目的是为了<strong>融合特征信息，使深层和浅层的信息融合起来</strong>，在拼接的时候要注意，<strong>不仅图片大小要一致（故要crop,是为了使图片大小一致）</strong>而且<strong>特征的维度（channels）也要一样</strong>，才可以拼接。</p><p><strong>Unet的好处我感觉是：网络层越深得到的特征图，有着更大的视野域，浅层卷积关注纹理特征，深层网络关注本质的那种特征，所以深层浅层特征都是有格子的意义的；另外一点是通过反卷积得到的更大的尺寸的特征图的边缘，是缺少信息的，毕竟每一次下采样提炼特征的同时，也必然会损失一些边缘特征，而失去的特征并不能从上采样中找回，因此通过特征的拼接，来实现边缘特征的一个找回。</strong></p><ol><li><strong>医疗影像的所有特征都很重要，因此低级特征和高级语义特征都很重要，所以U型结构的skip connection结构（特征拼接）更好派上用场</strong></li><li>医学影像数据较少，大网络容易过拟合</li><li><strong>医学影像任务中，往往需要自己设计网络去提取不同的模态特征，因此轻量结构简单的Unet可以有更大的操作空间</strong></li></ol><h3 id="Deeplab"><a href="#Deeplab" class="headerlink" title="Deeplab"></a>Deeplab</h3>]]></content>
      
      
      <categories>
          
          <category> 语义分割 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> FCN </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>In-camera image processing pipeline</title>
      <link href="in-camera-image-processing-pipeline/"/>
      <url>in-camera-image-processing-pipeline/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在进行之前先把学姐的汇报弄明白</p><p>首先是raw图像格式：<a href="https://zhuanlan.zhihu.com/p/158088019">https://zhuanlan.zhihu.com/p/158088019</a></p><p>ISP大佬的教程:<a href="https://ridiqulous.com/process-raw-data-using-matlab-and-dcraw/#brightnesscorrection">https://ridiqulous.com/process-raw-data-using-matlab-and-dcraw/#brightnesscorrection</a></p><p><strong>ISP pipeline：</strong></p><p><strong>线性处理</strong>-&gt;<strong>处理黑电平和饱和像素</strong>-&gt;<strong>白平衡</strong>，与颜色恒常性的白平衡不一样，仅仅是对三通道乘以增益系数，以补偿因为三种滤波片具有不同光谱灵敏度带来的影响-&gt;<strong>Demosaicking去马赛克/色彩插值</strong>-&gt;<strong>色彩空间转换</strong> 传感器光谱空间到CIEXYZ到sRGB-&gt;<strong>亮度矫正和伽马矫正</strong></p><img src="/in-camera-image-processing-pipeline/image-20201119091331032.png" alt="颜色空间变换的归一化" style="zoom:67%;"><p><strong>亮度矫正与伽马矫正</strong>之前都是线性变换，因为其实都可以乘一个矩阵将它变换回去，而亮度矫正和伽马矫正是非线性的。如果用Lab空间来描述的话，我们好像只关心ab通道的准确，并不关心L通道，L调合适就行了？不同显示器的物理亮度是不一样的，追求亮度的绝对准确复现没有意义，何况最亮的显示器也远无法复现真实世界里的最大亮度。</p><p><strong>伽马矫正</strong>：</p><p>维基百科：<a href="https://zh.wikipedia.org/wiki/%E4%BC%BD%E7%91%AA%E6%A0%A1%E6%AD%A3">https://zh.wikipedia.org/wiki/%E4%BC%BD%E7%91%AA%E6%A0%A1%E6%AD%A3</a></p><p>LearnOpenGL，这篇讲的挺好：<a href="https://learnopengl-cn.readthedocs.io/zh/latest/05%20Advanced%20Lighting/02%20Gamma%20Correction/">https://learnopengl-cn.readthedocs.io/zh/latest/05%20Advanced%20Lighting/02%20Gamma%20Correction/</a></p><p>简书教程：<a href="https://www.jianshu.com/p/321f39b7fa93">https://www.jianshu.com/p/321f39b7fa93</a></p><p><strong>RGB色彩空间是设备相关的？</strong></p><p><strong>wiki百科色彩空间：</strong><a href="https://zh.wikipedia.org/zh-cn/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93#cite_note-1">https://zh.wikipedia.org/zh-cn/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93#cite_note-1</a></p><p>RGB的实现方法有<strong>每原色8位或每原色16位</strong>，实际的RAW image可能是12位或14位，但是为了存储将它扩充到16位。</p><p>每台设备（如显示器或打印机）都有自己的色彩空间并只能生成其色域内的颜色。将图像从某台设备移至另一台设备时，因为每台设备按照自己的色彩空间解释 RGB 或 CMYK 值，所以图像颜色可能会发生变化。为了保证图像在不同设备上显示效果一致，必须使用色彩管理</p><p><strong>颜色匹配实验</strong>：<a href="https://zhuanlan.zhihu.com/p/84897327">https://zhuanlan.zhihu.com/p/84897327</a></p><p><strong>设备无关的颜色空间</strong>：<a href="http://www.doho17.cn/News/507.html">http://www.doho17.cn/News/507.html</a></p><p><strong>与设备有关的颜色空间对应的颜色印象如何取决于生成颜色的设备</strong>。例如：在某台计算机显示器上显示的红色与另一台显示器上显示的红色极有可能不同，这是因为每台显示器根据自己的色彩空间解释色的参数。而RGB、CMYK颜色空间都是与设备有关的颜色模型。</p><p><strong>Lab颜色模型</strong>是由CIE（国际照明委员会）制定的一种色彩模式。自然界中任何一点色都可以在Lab空间中表达出来，它的色彩空间比RGB空间还要大。另外，这种模式是以数字化方式来描述人的视觉感应，与设备无关，所以它弥补了RGB和CMYK模式必须依赖于设备色乡特性的不足。</p><p>这个RGB是指什么？就比如每个摄像机根据自己设备的色彩空间，就是设备相关的。sRGB是设备无关的，暂时理解就是指现在很多显示器都是用sRGB，所以是相对设备无关？？？而CIEXYZ则是完完全全把所有的色域都包括了，它是一个参照量，由它在转换到各个依赖于设备的颜色空间</p><p><strong>颜色空间是什么？就是满足我们的设备我们的显示标准的一个颜色配置标准，比如在a颜色空间1是黄色，但是b颜色空间我们设置2是黄色，大概就是这个意思</strong></p>]]></content>
      
      
      <categories>
          
          <category> Color Constancy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 颜色空间 </tag>
            
            <tag> 相机成像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人像肤色区域检测</title>
      <link href="ren-xiang-fu-se-jian-ce/"/>
      <url>ren-xiang-fu-se-jian-ce/</url>
      
        <content type="html"><![CDATA[<h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>肤色区域检测是肤色定级的前提，只有正确的将图像中人体的肤色区域检测出来，才能探究人体皮肤的肤色感光差异以及分布规律，从而选择更合适的颜色空间并做出更好的划分。</p><p>皮肤检测任务方法类别？</p><p>指标较高的方法和模型？</p><p>肤色定级的不同颜色空间为啥如此定义研究的更深一点？–之后</p><p>学习阶段：现有的算法有哪些可以不全面 ？   可以分为几大类？    看综述怎样分类的？ 指标结果贴出来 </p><p>自己试验：一两个几个重要的算法复现了  前沿的？都没有的话复现最先进  拿数据集跑跑   </p><h3 id="Human-Skin-Detection-Using-RGB-HSV-and-YCbCr-Color-Models"><a href="#Human-Skin-Detection-Using-RGB-HSV-and-YCbCr-Color-Models" class="headerlink" title="Human Skin Detection Using RGB, HSV and YCbCr Color Models"></a>Human Skin Detection Using RGB, HSV and YCbCr Color Models</h3><h4 id="Info"><a href="#Info" class="headerlink" title="Info"></a>Info</h4><p>2017年 引用次数102 会议：ICCASP 怎么感觉查不到这个会议？</p><h4 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h4><p>皮肤颜色具有对方向和大小不变性和处理速度快等特点，常用于人体皮肤检测中。提出了一种新的人体皮肤检测算法。识别皮肤像素的三个主要参数是RGB(红、绿、蓝)、HSV(色调、饱和度、值)和YCbCr(亮度、色度)颜色模型。不仅考虑了三种颜色参数的单独范围，而且考虑了交流计数的组合范围，从而提高了识别给定图像皮肤区域的精度。</p><h4 id="Conclusion"><a href="#Conclusion" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>基于阈值的算法，能够处理不同光照条件下的图像，未来应用可能在脸部、手势识别、皮肤病检测等</p><h4 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h4><p>作为预处理步骤，识别关键是皮肤颜色。其他因素如光照条件也会影响结果，所以常常与纹理、边缘特征等线索相结合。</p><p>检测方式是判断单个像素是否位于我们设定的颜色范围，本文是结合RGB、HSV和YCbCr三个颜色空间设定阈值。</p><h4 id="Literature-Review"><a href="#Literature-Review" class="headerlink" title="Literature Review"></a>Literature Review</h4><p>皮肤检测技术可以大致分为<strong>基于像素的技术</strong>和<strong>基于区域的技术</strong>。<strong>pixel-based</strong> <strong>region-based</strong></p><p>在基于像素的皮肤检测中，每个像素根据一定的条件分别被分为皮肤像素和非皮肤像素。基于颜色值的皮肤检测是基于像素的。</p><p>基于区域的皮肤检测技术考虑<strong>像素点的空间关系</strong>.初始皮肤区域不断判断周围皮肤的属性来增大。</p><h4 id="Color-Spaces"><a href="#Color-Spaces" class="headerlink" title="Color Spaces"></a>Color Spaces</h4><p><strong>基于RGB</strong>：RGB,normalized RGB</p><p>规范化RGB就是一个normalized过程$e.g. r=\frac{R}{R+G+B}$</p><p><strong>基于色调Hue-based</strong>：HSI,HSV,HSL</p><p><strong>基于亮度Luminance-based</strong>:YCbCr,YIQ,YUV</p><p>亮度信息存储为单个分量(Y)，而色度信息存储为两个色差分量(Cb和Cr)。Cb表示蓝色分量与参考值之差。Cr表示红色分量与参考值的差值。</p><p><img src="/ren-xiang-fu-se-jian-ce/image-20201119112418920.png" alt="RGB->YCbCr"></p><h4 id="Proposed-Skin-Detection-Algorithm"><a href="#Proposed-Skin-Detection-Algorithm" class="headerlink" title="Proposed Skin Detection Algorithm"></a>Proposed Skin Detection Algorithm</h4><p>ARGB color model:<a href="https://en.wikipedia.org/wiki/RGBA_color_model">https://en.wikipedia.org/wiki/RGBA_color_model</a></p><p><img src="/ren-xiang-fu-se-jian-ce/image-20201119145342738.png" alt="ARGB32位"></p><p>利用右移操作和与0xff按位与，得到每个通道值，然后根据下图的阈值判断：</p><p><img src="/ren-xiang-fu-se-jian-ce/image-20201119145454111.png" alt="阈值"></p><p>这个阈值如何获得的？</p><h4 id="Experiments-Resuts"><a href="#Experiments-Resuts" class="headerlink" title="Experiments Resuts"></a>Experiments Resuts</h4><img src="/ren-xiang-fu-se-jian-ce/image-20201119145605005.png" alt="实验结果" style="zoom:80%;"><img src="/ren-xiang-fu-se-jian-ce/image-20201119145623528.png" alt="精确率和准确率" style="zoom:80%;"><p>还有一点就不贴图了，即这三个颜色空间所获得的结果是差不多的。</p><h3 id="Combining-Convolutional-and-Recurrent-Neural-Networks-for-Human-Skin-Detection"><a href="#Combining-Convolutional-and-Recurrent-Neural-Networks-for-Human-Skin-Detection" class="headerlink" title="Combining Convolutional and Recurrent Neural Networks for Human Skin Detection"></a>Combining Convolutional and Recurrent Neural Networks for Human Skin Detection</h3><h4 id="Info-1"><a href="#Info-1" class="headerlink" title="Info"></a>Info</h4><p>年份：2017  </p><p>引用次数：72</p><p>期刊：IEEE SIGNAL PROCESSING LETTERS  JCR分区Q2</p><h4 id="Abstract-1"><a href="#Abstract-1" class="headerlink" title="Abstract"></a>Abstract</h4><p>高效的传统手工设计的肤色检测算法需要领域专家的广泛工作</p><p>CNN在像素级标记任务中取得了巨大的成功。CNN的架构不足以建模像素与其邻居之间的关系。引进RNN。FCN层捕获一般的局部特征，RNN层建模图像中的语义上下文依赖。在COMPAO和ECU皮肤数据集上验证了方法的有效性，其中RNN层增强了复杂背景下皮肤检测的识别能力。</p><h4 id="Conclusion-1"><a href="#Conclusion-1" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>利用RNN层对图像像素间的语义空间依赖进行建模。</p><h4 id="Introduction-1"><a href="#Introduction-1" class="headerlink" title="Introduction"></a>Introduction</h4><p>在许多常用的颜色空间中，皮肤像素和非皮肤像素之间有明显的重叠。例如，背景中的许多物体，如墙壁、木材和布料，可能与不同类型的人类皮肤有着相似的颜色。在不考虑相邻像素的情况下，很难确定单个像素是皮肤还是非皮肤。此外，皮肤检测的性能还受到多种其他因素的影响(光照不均匀、相机特性、受试者种族、年龄、性别等)。<br>最近的研究集中在：</p><p>不同的颜色空间(如RGB [9], YCbCr [10], CIE-XYZ [11], HSV[12],和SKN[13])</p><p>特征提取(如颜色[14],纹理[15],和空间分布[16])</p><p>分类方法(贝叶斯分类器[9],高斯混合模型[17],支持向量机[18],神经网络[19],随机森林[20]等等)。</p><p>基于cnn的架构不擅长建模像素和它们的邻居之间的关系。最近，Zheng等人[27]在CNN的最后一层引入了<strong>条件随机场</strong>来细化粗略的预测。</p><h4 id="Problem-Statement-amp-Method"><a href="#Problem-Statement-amp-Method" class="headerlink" title="Problem Statement &amp; Method"></a>Problem Statement &amp; Method</h4><h4 id="Experiments-and-Analysis"><a href="#Experiments-and-Analysis" class="headerlink" title="Experiments and Analysis"></a>Experiments and Analysis</h4><p>Matlab环境  什么颜色空间仍然是开放问题，但是有人证明性能在某种程度上是独立于颜色空间的</p><p><strong>双线性插值？</strong></p><p>应用：</p><ol><li>对数据中的缺失进行合理补偿 </li><li>对数据进行放大或缩小</li><li>其他</li></ol><p>通俗易懂啊！<a href="https://www.cnblogs.com/linkr/p/3630902.html">https://www.cnblogs.com/linkr/p/3630902.html</a></p><p>图像插值的举例说明：<a href="https://www.cnblogs.com/yssongest/p/5303151.html">https://www.cnblogs.com/yssongest/p/5303151.html</a></p><p>单线性插值：单变量只有一个x，对y进行插值，线性插值原理是两个点可以确定一条直线，又可以根据x确定y<br>$$<br>\frac{y-y_0}{x-x_0}=\frac{y_1-y_0}{x_1-x_0}\<br>y=\frac{x_1-x}{x_1-x_0}y_0+\frac{x-x_0}{x_1-x_0}y_1\<br>y=k\cdot y0+(1-k)\cdot y_1 \quad \quad<br>$$</p><p>双线性插值：有两个变量x、y，分别在x、y两个方向进行插值</p><p><img src="/ren-xiang-fu-se-jian-ce/image-20201120155633758.png" alt="很棒！"></p><p>对于一个目的像素，设置坐标通过反向变换得到的浮点坐标为$(i+u,j+v)$(其中$i、j$均为浮点坐标的整数部分，$u、v$为浮点坐标的小数部分，是取值[0,1)区间的浮点数)，则这个像素得值$f(i+u,j+v)$可由原图像中坐标为$(i,j)(i+1,j)(i,j+1)(i+1,j+1)$所对应的周围四个像素的值决定，即:$f(i+u,j+v) = (1-u)(1-v)f(i,j) + (1-u)vf(i,j+1) + u(1-v)f(i+1,j) + uvf(i+1,j+1)$</p><p>现在假如目标图的象素坐标为$(1,1)$，那么反推得到的对应于源图的坐标是$(0.75,0.75)$, 这其实只是一个概念上的虚拟象素,实际在源图中并不存在这样一个象素,那么目标图的象素$（1,1）$的取值不能够由这个虚拟象素来决定，而只能由源图的这四个象素共同决定：$(0,0)(0,1)(1，0)(1,1)$，而由于$(0.75,0.75)$离$(1,1)$要更近一些，那么$(1,1)$所起的决定作用更大一些，这从公式1中的系数$uv=0.75×0.75$就可以体现出来，而$(1,1)$离$(0.75,0.75)$最远，所以$(0,0)$所起的决定作用就要小一些，公式中系数为$(1-u)(1-v)=0.25×0.25$也体现出了这一特点。</p><p><strong>实验设置</strong></p><ul><li>FCN初始权值：预训练的FCN-8s </li><li>RNN初始权值：正态分布随机数</li><li>最优化方法：带动量SGD，动量0.9</li><li>学习速率：10^-7固定学习速率，<a href="https://blog.csdn.net/qq_17464457/article/details/101846874?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromBaidu-1.not_use_machine_learn_pai">bias加倍的学习速率</a></li><li>20个epoch per image 55ms</li></ul><p><strong>数据集</strong></p><ul><li>COMPAQ 只使用了4670皮肤图像 &amp; ECU 1000测试 3000训练</li><li>提供了GT skin masks 和 versatile attributes</li><li>COMPAQ结果相对ECU较差，因为数据集质量较差，包含大量低质量图像和半自动的GT</li></ul><p><strong>实验结果</strong></p><ul><li>混淆矩阵</li><li>the receiver operating characteristics <a href="https://www.jianshu.com/p/2ca96fce7e81">ROC</a> TPR和FPR 两个指标相互有点制衡 ROC相比P-R曲线更稳定，样本数量改变后不会振荡 ROC曲线的<strong>绘制</strong>：调整不同阈值设置，每个阈值在ROC空间上产生一个不同点  ‘*‘表示最佳工作点，由斜率Slope得到</li><li>respective area under curve AUC ROC曲线下的面积 物理意义：</li><li>equal error rate 1-EER</li><li>FCN8s+RNN的最终输出层为2通道的softmax，做二分类，设置阈值，超过阈值为皮肤，否则为非皮肤。</li><li>注意，对现有的alogrithm进行比较是困难的，因为它们要么使用不同的评估指标，要么使用非公共数据集，要么使用任意的操作点(或阈值)。</li></ul><img src="/ren-xiang-fu-se-jian-ce/image-20201120174744122.png" alt="Compaq" style="zoom:50%;"><img src="/ren-xiang-fu-se-jian-ce/image-20201120174807952.png" alt="ECU" style="zoom:50%;"><h3 id="Semi-supervised-Skin-Detection-by-Network-with-Mutual-Guidance"><a href="#Semi-supervised-Skin-Detection-by-Network-with-Mutual-Guidance" class="headerlink" title="Semi-supervised Skin Detection by Network with Mutual Guidance"></a>Semi-supervised Skin Detection by Network with Mutual Guidance</h3><h4 id="Info-2"><a href="#Info-2" class="headerlink" title="Info"></a>Info</h4><p>年份：2019</p><p>会议：ICCV</p><p>Megvii Technology 旷视研究院</p><h4 id="Abstract-2"><a href="#Abstract-2" class="headerlink" title="Abstract"></a>Abstract</h4><p>a single human portrait image-&gt;结合人体作为弱语义指导， 考虑到获取大规模的人体标记皮肤数据通常是昂贵和费时的-&gt;半监督学习策略进行皮肤和身体联合检测的dual-task network-&gt;一个共享编码器，分别用于皮肤和身体的两个解码器，两个解码器可以互相引导</p><h4 id="Conclusion-2"><a href="#Conclusion-2" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>半监督训练，即不需要一个训练样本存在两种GT</p><h4 id="Introduction-2"><a href="#Introduction-2" class="headerlink" title="Introduction"></a>Introduction</h4><p>之前的方法</p><p>Combining haar feature and skin color based classifiers for face detection 2011 ICASSP</p><p>Adaptive learning of an accurate skin-color model 2004 ICAFGR</p><p>尝试在不同的颜色空间中建模皮肤颜色，并在这些空间中训练皮肤分类器</p><p>缺点：严重依赖于肤色的分布，并且没有涉及到语义信息，因此性能有限。</p><p>基于其他检测任务的DNN的改进受限于皮肤数据</p><p>引入人体检测的两个优势：</p><ul><li>为皮肤位置提供先验信息</li><li>检测到皮肤后，可以过滤掉False positive</li></ul><p>皮肤检测也为人体检测提供了信息</p><p><strong>两个检测器的共享编码器会考虑到两个任务的相似性和网络的紧凑性，从输入图像中提取共同的特征图。这种结构使我们在训练皮肤检测网络时不需要增加带注释的训练数据，而只需要增加一个人体面罩数据集，这更容易获得。由于这两个数据集分别包含两种ground truth类型，即一个数据样本中要么有一个目标skin mask，要么有一个body mask，因此我们采用新设计的loss和自定义的训练策略对网络进行半监督的训练。</strong></p><h4 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h4><p><strong>Skin detection and segmentation</strong></p><p>现有的方法可以分为三类:</p><ol><li>在颜色空间上明确定义边界模型/阈值-划分区域定皮肤像素-皮肤和非皮肤像素存在明显重叠</li><li>,应用传统机器学习技术学习种肤色模型-生成/判别模型预测，可能考虑到纹理等局部特征-学习能力有限，精度较低</li><li>利用深度神经网络学习皮肤分割的端到端模型–MLP-&gt;FCN,需要大规模监督-&gt;18CVPR Normalized cut loss for weakly-supervised cnn segmentation 引入条件随机场，使弱监督成为可能-&gt;本文引用额外数据集提高性能</li></ol><p><strong>Multi-task joint learning</strong></p><p>它通常通过在所有任务之间共享隐藏层来应用，同时保留几个特定于任务的输出层作为分支。</p><p>一些多任务网络通常通过共享编码器来学习共同的特征图，从而潜在地同时提高所有任务的性能。</p><h4 id="Experimental-Results"><a href="#Experimental-Results" class="headerlink" title="Experimental Results"></a>Experimental Results</h4><p>**Dataset and Implementation Details **</p><ul><li>10711 RGB images 5000 skin masks 5711 body masks 网络收集 512x512分辨率 </li><li>随机选择470S和475B，作验证集  随即翻转/调整/裁剪-训练数据增强</li><li>Tensorflow NVIDIA GeForce GTX 1080Ti GPU 训练了12个小时</li></ul><p><strong>Comparison with Existing Methods</strong></p><ul><li>2种传统算法 六种NN算法</li><li>Human skin color clustering for face detection  2003 IEEE RGB和HSV空间定阈值</li><li>Statistical color models with application to skin detection 2002 IJCV 学习GMM预测</li><li>缺陷：缺乏高级特征，对复杂环境和光照变化鲁棒性差</li><li>A skin detector based on neural network 2002 ICCCSWSE</li><li>Combining convolutional and recurrent neural networks for human skin detection 2017 SPL</li><li>U- net: Convolutional networks for biomedical image segmentation 2015</li><li>Deep residual learning for image recognition 2016CVPR</li><li>Encoder-decoder with atrous separable convolution for semantic image segmentation 2018ECCV</li></ul><p>We trained the six networks to convergence收敛 with multiple trials实验 with dataset DS, and selected their best results</p><p>For recall, our method ranks only below the GMM method, which has more false alarms so as to suffer from a poor precision. </p><p>定量比较-Table1 Figure6 平衡和不平衡 此文数据集与Pratheepan IoU IoU Top-1 Precision Recall </p><p>几个典型预测结果-Figure5 Figure1 这几个典型带有各种挑战性 传统方法完全失败 其他CNN不稳定 我们的有效且可靠</p><p><strong>Ablation Studies</strong></p><p><a href="https://www.zhihu.com/question/60170398">ablation study</a></p><p>去掉某些特征 模型 算法 对结果会有什么影响，就是控制变量，为了研究你提出的方法是不是有效 </p><p>根据奥卡姆剃刀法则，简单和复杂的方法能达到一样的效果，那么简单的方法更可靠。</p><p><strong>1-Mutual guidance</strong></p><p>Figure4 显示有无互指导的效果 即使没有互指导 也比单任务最好的好 因为共享编码器从身体数据学到了信息</p><p><strong>2-Weakly supervised losses</strong></p><p>Table2Top虽不显著 确实起到了作用</p><p>Figure3 显示了一个例子 不同的弱监督损失的作用</p><p><strong>3-Unbalanced dataset</strong></p><p>Figure1 若使用 不平衡数据集   IoU下降约%6 但仍比其他的高</p><p><strong>4-Backbone networks</strong></p><p>Table2Bottom Mobile-Net 替换UNet IoU相对较低 但互指导起到的作用更大</p><p><strong>5-Training strategy</strong></p><ul><li>Gradient stopping Figure7 </li><li>Initial guidance  给个先验会好一点</li><li>Finetune Figure4 Top <strong>train-from-scratch</strong> and <strong>finetune versions</strong>  有没有预训练</li></ul><h4 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h4><p>双任务FCN 输入一个RGB图像I 输出 skin Os 和 body Ob的概率图 两个解码器Ds Db 编码器E输出I的特征图Ei Os和Ei送到Db 反之亦然  网络结构 Figure2a</p><p><strong>1-Network with Mutual Guidance</strong></p><p>Figue2b 将原始网络解耦为没有循环的两个阶段 X表示Stage1 X‘ Stage2 Xk包括Xs和Xb</p><p>I E Dk 相同 Gk和Gk’不同 第一阶段信息很少而第二阶段有Ok作为指引</p><p>Table1 Figure4共享编码器考虑：</p><ol><li>虽然两个任务GT不同，但具有相似的统计信息</li><li>特征图具有共性，如区分人的前景和非人的背景的鲁棒性</li></ol><p><img src="/ren-xiang-fu-se-jian-ce/image-20201122214758315.png" alt="网络结构"></p><p>es eb 第一阶段的指导 一般设为0 应该是一直为0，不会变     E和Dk的结构采用了标准UNet，包括E中的4个下采样 Dk中的4个上采样 </p><p>输入512x512x3  E-&gt;Dk 的特征映射Ei 32x32x1024  另外应用了一个和E相同结构但是通道数只有一半的编码器给Gk，然后将输出与Ei相连，再喂给Dk</p><p>每个FCN层 kernel size 3x3 后面是一个BatchNorm和一个ReLu层</p><p><strong>2-Learning Algorithm</strong></p><p>对于人体检测，由于广泛研究，数据易得 所以对每个数据对，只提供Ms或Mb 很少提供（I，Ms，Mb）所以是一个半监督任务</p><p>这主要有半监督损失和具体训练细节实现</p><p><strong>2.1Semi-supervised loss</strong></p><p>半监督损失由三部分组成，包括：strongly-supervised and weakly-supervised ones</p><p>再有GT的一侧算Cross-entropy loss 另一侧算CRF loss 两个输出集合起来算WCE loss，</p><p><strong>Cross-entropy loss</strong></p><p><img src="/ren-xiang-fu-se-jian-ce/image-20201123092722193.png" alt="Cross-entropy loss"></p><p>where $L_{ce}(x,y)=x\cdot log(y)+(1-x)\cdot log(1-y)$       $l_k$表示一委托个数据样例是否含有GT$M_k$</p><p><strong>CRF loss</strong></p><p>从 On regularized losses for weakly-supervised cnn segmentation 2018ECCV 引入CRFLoss CRF可以使I中颜色相同且相邻的像素在</p><p><img src="/ren-xiang-fu-se-jian-ce/image-20201123093447500.png" alt="CRF loss"></p><p>where  $L_{crf}=S^TWS$  W是I的Affinity Matrix S是平坦化的Ok的列向量   具体看论文</p><p><strong>WCE loss</strong></p><p>输出之间也有限制，皮肤概率高的话，那么身体概率也应该高，也就是两个分布一致，皮肤概率低的话，就没有限制了，所以用皮肤概率做权重，限定WCE loss 对总体的影响</p><p><img src="/ren-xiang-fu-se-jian-ce/image-20201123100039914.png" alt="WCE Loss"></p><p>$L_{wce}(x,y)=x\cdot L_{ce}(x,y)$</p><p><strong>semi-supervised loss</strong></p><p><img src="/ren-xiang-fu-se-jian-ce/image-20201123100808245.png" alt="semi-supervised loss"></p><p>$\lambda_1=0.0001 \quad \lambda_2=0.001 $</p><p><strong>2.2Training details</strong><br><strong>Dual-task joint learning</strong></p><p>奇数次和偶数次分别喂MB和MS，用Lk来指导算loss</p><p><strong>Finetune</strong></p><p><img src="/ren-xiang-fu-se-jian-ce/image-20201124205344966.png" alt="Stage2 Guidance"></p><p>有GT的就直接用真实的指导就行</p><p>两个阶段的指导变化很大，但是他们使用相同的解码器权重,不然G’反向传播，防止Decoder参数对G‘过拟合，对G欠拟合</p><h3 id="SKINNY-A-LIGHTWEIGHT-U-NET-FOR-SKIN-DETECTION-AND-SEGMENTATION"><a href="#SKINNY-A-LIGHTWEIGHT-U-NET-FOR-SKIN-DETECTION-AND-SEGMENTATION" class="headerlink" title="SKINNY: A LIGHTWEIGHT U-NET FOR SKIN DETECTION AND SEGMENTATION"></a>SKINNY: A LIGHTWEIGHT U-NET FOR SKIN DETECTION AND SEGMENTATION</h3><h4 id="Info-3"><a href="#Info-3" class="headerlink" title="Info"></a>Info</h4><p>2020ICIP</p><h4 id="Abstract-3"><a href="#Abstract-3" class="headerlink" title="Abstract"></a>Abstract</h4><p>lightweight轻量的</p><p>全卷积UNet对图像分割很有效</p><p> 空间上下文对皮肤分隔很重要，对UNet很狭窄是什么意思</p><p>扩展了多尺度分析的范围</p><p>在ECU和HGR测试</p><h4 id="Conclusion-3"><a href="#Conclusion-3" class="headerlink" title="Conclusion"></a>Conclusion</h4><p>Skinny受益与几个架构组件,包括inception和dense blocks，从而更好利用上下文 </p><p>inception和dense很关键，并且不影响速度</p><p>未来：增强上下文像素分析思想，使用扩张卷积，保持参数低数量，减少FP</p><h4 id="Introduction-3"><a href="#Introduction-3" class="headerlink" title="Introduction"></a>Introduction</h4><p>由于皮肤外观的低特异性和高方差，该问题仍具有挑战性</p><h4 id="Figure"><a href="#Figure" class="headerlink" title="Figure"></a>Figure</h4><p>图一 UNet没有足够上下文，分类错了，Skinny考虑到更广泛背景，分类正确了</p><p>图二 网络结构和两种变体</p><p><a href="https://www.jianshu.com/p/587c3a45df67">上采样</a>      <a href="https://blog.csdn.net/LoseInVain/article/details/81098502">转置卷积</a></p><p> <a href="https://blog.csdn.net/u014380165/article/details/75142664">DenseNet</a>      </p><p>注意语义分割和实例分割的区别，语义分割是人都归为一类，实例分割是不同的人标成不同的类 </p><p> <a href="https://zhuanlan.zhihu.com/p/83496100">全景分割</a>将语义分割和实例分割结合在一起，既能分割背景，也能分割实例   </p><p><a href="https://www.sohu.com/a/284185732_129720">全景分割</a>图像中的内容可以按照是否有固定形状分为 things 类别和 stuff 类别，其中，人，车等有固定形状的物体属于 things 类别（可数名词通常属于 things）；天空，草地等没有固定形状的物体属于 stuff 类别（不可数名词属于 stuff）</p><h4 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h4><p><a href="https://www.aiuai.cn/aifarm1159.html">dice-loss</a>  对于二分类问题，GT 分割图是只有 0, 1 两个值的，因此 |X⋂Y| 可以有效的将在 Pred 分割图中未在 GT 分割图中激活的所有像素清零. 对于激活的像素，主要是惩罚低置信度的预测，较高值会得到更好的 Dice 系数.   </p><p>意思就是说主要注重皮肤点预测的怎么样，非皮肤点的预测就不管了</p>]]></content>
      
      
      <categories>
          
          <category> 肤色分级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 肤色分级 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>oj-1</title>
      <link href="codeforces-1/"/>
      <url>codeforces-1/</url>
      
        <content type="html"><![CDATA[<h2 id="1A-Theatre-Square-math"><a href="#1A-Theatre-Square-math" class="headerlink" title="1A Theatre Square-math"></a>1A Theatre Square-math</h2><p>#include&lt;bits/stdc++.h&gt;</p><p>using namespace std</p><p>注意查看变量取值范围,可能数超大，本题就得使用long long定义</p><p>向上取整$ceil()$,向下取整$floor()$,四舍五入到最近整数$round()$,注意返回值是浮点数！</p><p>c++API：<a href="https://devdocs.io/cpp/">https://devdocs.io/cpp/</a></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>a<span class="token punctuation">;</span>    <span class="token function">scanf</span><span class="token punctuation">(</span><span class="token string">"%lld %lld %lld"</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>n<span class="token punctuation">,</span><span class="token operator">&amp;</span>m<span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> rows<span class="token punctuation">,</span>cols<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>n<span class="token operator">%</span>a<span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        rows<span class="token operator">=</span>n<span class="token operator">/</span>a<span class="token punctuation">;</span>    <span class="token keyword">else</span>         rows<span class="token operator">=</span>n<span class="token operator">/</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">%</span>a<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        cols<span class="token operator">=</span>m<span class="token operator">/</span>a<span class="token punctuation">;</span>    <span class="token keyword">else</span>         cols<span class="token operator">=</span>m<span class="token operator">/</span>a<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%lld"</span><span class="token punctuation">,</span>rows<span class="token operator">*</span>cols<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> </code></pre><h2 id="71A-Way-Too-Long-Words-strings"><a href="#71A-Way-Too-Long-Words-strings" class="headerlink" title="71A Way Too Long Words-strings"></a>71A Way Too Long Words-strings</h2><p>c++: string 建议是在程序中<strong>能使用C++字符串就使用</strong>，除非万不得已<strong>不选用c_string</strong>。</p><p>c++string教程：<a href="https://www.cnblogs.com/c1299401227/p/5370685.html">https://www.cnblogs.com/c1299401227/p/5370685.html</a></p><p><a href="https://blog.csdn.net/qq_42659468/article/details/90381985">https://blog.csdn.net/qq_42659468/article/details/90381985</a></p><p><a href="https://blog.csdn.net/liitdar/article/details/80498634">https://blog.csdn.net/liitdar/article/details/80498634</a></p><p><strong>重定向</strong>：</p><p>//freopen(“in.txt”,”r”,stdin);</p><p>输入输出：</p><p><img src="/codeforces-1/image-20201116202224462.png" alt="输入输出"></p><p>对于这种类型的题，可以输入一个输出一个，用如下方式：</p><p>while(n–){ }</p><p>c语言字符串:  char word[nmax]; scanf(“%s”,word); strlen()</p><p>必须要指明nmax，你就算是定义数字数组也要指明nmax呀，否则就得动态分配。</p><p>c语言字符串教程：<a href="https://www.cnblogs.com/tongye/p/10688941.html">https://www.cnblogs.com/tongye/p/10688941.html</a></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    cin<span class="token operator">>></span>n<span class="token punctuation">;</span>    string s<span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cin<span class="token operator">>></span>s<span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">></span><span class="token number">10</span><span class="token punctuation">)</span>            cout<span class="token operator">&lt;&lt;</span>s<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">2</span><span class="token operator">&lt;&lt;</span>s<span class="token punctuation">[</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>        <span class="token keyword">else</span>            cout<span class="token operator">&lt;&lt;</span>s<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意换行</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="118-A-String-Task-string"><a href="#118-A-String-Task-string" class="headerlink" title="118 A String Task-string"></a>118 A String Task-string</h2><p>字符串<strong>大小写转换</strong>：没有直接的转换函数，可以<strong>直接利用ascii码字符加减</strong></p><p>对字符串变换，<strong>可以新设一个字符串，也可逐字符输出，是个黑盒子，它不管你怎么操作的，结果对了就行</strong></p><pre class=" language-c"><code class="language-c"> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'a'</span><span class="token operator">||</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'e'</span><span class="token operator">||</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'i'</span><span class="token operator">||</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'o'</span><span class="token operator">||</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'u'</span><span class="token operator">||</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'y'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//这里做一个假删除</span> <span class="token punctuation">}</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"."</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//这一步很重要</span>   <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%c"</span><span class="token punctuation">,</span>str<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string s<span class="token punctuation">;</span>    cin<span class="token operator">>></span>s<span class="token punctuation">;</span>    string ans<span class="token operator">=</span><span class="token string">""</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">>=</span><span class="token string">'A'</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">&lt;=</span><span class="token string">'Z'</span><span class="token punctuation">)</span>            s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">=</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">-</span><span class="token string">'A'</span><span class="token operator">+</span><span class="token string">'a'</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'a'</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'o'</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'y'</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'e'</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'u'</span><span class="token operator">&amp;&amp;</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token string">'i'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            ans<span class="token operator">=</span>ans<span class="token operator">+</span><span class="token string">'.'</span><span class="token operator">+</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span>ans<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="78A-Football"><a href="#78A-Football" class="headerlink" title="78A Football"></a>78A Football</h2><p>连续子串等连续问题，可以设一个变量或数组，每一次修改都在前一位的基础上修改</p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    string s<span class="token punctuation">;</span>    cin<span class="token operator">>></span>s<span class="token punctuation">;</span>    <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>flag<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>s<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'0'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            a<span class="token operator">++</span><span class="token punctuation">;</span>            b<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            a<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>            b<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>a<span class="token operator">==</span><span class="token number">7</span><span class="token operator">||</span>b<span class="token operator">==</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            flag<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"YES"</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>flag<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span>        cout<span class="token operator">&lt;&lt;</span><span class="token string">"NO"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="230A-Dragons"><a href="#230A-Dragons" class="headerlink" title="230A Dragons-"></a>230A Dragons-</h2><p>c++中sort函数使用方法：<a href="https://www.cnblogs.com/junbaobei/p/10776066.html">https://www.cnblogs.com/junbaobei/p/10776066.html</a></p><p>迭代器：<a href="https://blog.csdn.net/qq_34777600/article/details/80427463">https://blog.csdn.net/qq_34777600/article/details/80427463</a></p><p>sort小总结：<a href="https://blog.csdn.net/yulijuanxmu/article/details/80148417">https://blog.csdn.net/yulijuanxmu/article/details/80148417</a></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span>using namespace std<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//typedef struct node{//这种使用typedef 也可以不用 不一定非要用链表 </span><span class="token comment" spellcheck="true">//    int x;</span><span class="token comment" spellcheck="true">//    int y;</span><span class="token comment" spellcheck="true">//}Dragon; </span><span class="token keyword">struct</span> Dragon<span class="token punctuation">{</span>    <span class="token keyword">int</span> x<span class="token punctuation">;</span>    <span class="token keyword">int</span> y<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意分号 </span>bool <span class="token function">cmp</span><span class="token punctuation">(</span>Dragon a<span class="token punctuation">,</span>Dragon b<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">return</span> a<span class="token punctuation">.</span>x<span class="token operator">&lt;</span>b<span class="token punctuation">.</span>x<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//前面的小于后面的，排序也一致 </span><span class="token punctuation">}</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> s<span class="token punctuation">,</span>n<span class="token punctuation">;</span>    cin<span class="token operator">>></span>s<span class="token operator">>></span>n<span class="token punctuation">;</span>    Dragon dragons<span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cin<span class="token operator">>></span>dragons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token operator">>></span>dragons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token function">sort</span><span class="token punctuation">(</span>dragons<span class="token punctuation">,</span>dragons<span class="token operator">+</span>n<span class="token punctuation">,</span>cmp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token operator">></span>dragons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span>            s<span class="token operator">+</span><span class="token operator">=</span>dragons<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token punctuation">{</span>            cout<span class="token operator">&lt;&lt;</span><span class="token string">"NO"</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//得到了想要的可以直接return </span>            <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    cout<span class="token operator">&lt;&lt;</span><span class="token string">"YES"</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="455A-Boredom-dp"><a href="#455A-Boredom-dp" class="headerlink" title="455A Boredom-dp"></a>455A Boredom-dp</h2><p>动态规划：从新手到专家:<a href="http://hawstein.com/2013/03/26/dp-novice-to-advanced/">http://hawstein.com/2013/03/26/dp-novice-to-advanced/</a></p><p><strong>子串</strong>:串中任意个连续的字符组成的子序列称为该串的子串. </p><p><strong>子序列</strong>:子数列，又称子序列，在数学中，某个序列的子序列是从最初序列通过,去除某些元素但不破坏余下元素的相对位置（在前或在后）而形成的新序列。</p><h2 id="1359B-New-Theatre-Square"><a href="#1359B-New-Theatre-Square" class="headerlink" title="1359B New Theatre Square"></a>1359B New Theatre Square</h2><p>第一次遇见时间超时的问题</p><p><strong>一般1s执行10^8次运算</strong></p><p>按道理来说没事，反正一开始写的代码很多，很乱，其实是个很简单的问题，不知道为啥写的那么乱</p><p>利用一个$y=min(2*x,y)$函数，<strong>将两块砖统一起来了</strong> </p><p><strong>没必要字符矩阵，字符串也是一行一行处理的，最好是string</strong></p><p>挺简单的一道题，不知道为啥做了这么久</p><pre class=" language-cpp"><code class="language-cpp"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span><span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    cin<span class="token operator">>></span>t<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">int</span> n<span class="token punctuation">,</span>m<span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">;</span>        cin<span class="token operator">>></span>n<span class="token operator">>></span>m<span class="token operator">>></span>x<span class="token operator">>></span>y<span class="token punctuation">;</span>        y<span class="token operator">=</span><span class="token function">min</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token operator">*</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>n<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            string s<span class="token punctuation">;</span>            cin<span class="token operator">>></span>s<span class="token punctuation">;</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>j<span class="token operator">&lt;</span>m<span class="token punctuation">;</span>j<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>s<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span><span class="token punctuation">(</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token operator">&lt;</span>m <span class="token operator">&amp;</span> s<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">==</span><span class="token string">'.'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        ans<span class="token operator">+</span><span class="token operator">=</span>y<span class="token punctuation">;</span>                        j<span class="token operator">++</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//注意这一步，然后一次相当于加了2</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">else</span><span class="token punctuation">{</span>                        ans<span class="token operator">+</span><span class="token operator">=</span>x<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>         <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="1440B-Sum-of-Medians-greedy"><a href="#1440B-Sum-of-Medians-greedy" class="headerlink" title="1440B Sum of Medians-greedy"></a>1440B Sum of Medians-greedy</h2><p>贪心算法，又名贪婪法，是寻找最优解问题的常用方法，这种方法模式一般将求解过程分成若干个步骤，但每个步骤都应用贪心原则，<strong>选取当前状态下最好/最优的选择（局部最有利的选择）</strong>，并以此希望最后堆叠出的结果也是最好/最优的解。{看着这个名字，贪心，贪婪这两字的内在含义最为关键。这就好像一个贪婪的人，他<strong>事事都想要眼前看到最好的那个，看不到长远的东西，也不为最终的结果和将来着想，贪图眼前局部的利益最大化，有点走一步看一步的感觉</strong>。</p><p>对于本题，认真读还是人家的教程讲得好！</p><p><img src="/codeforces-1/image-20201119000826288.png" alt="教程"></p><p><strong>主要是怎么证明他就是最值，我们想象有k个选定的中值，只要每个数前面还有$ceil(n/2)-1$个元素多于他们，那么他们就可以一直往前移动，只要他们往前移动，那么就是非减的。</strong></p><p>本题注意<strong>ans要用long long int存储</strong>，因为正常的int只有$-2^{31}\sim 2^{31}-1$,所以每个数最大是$10^9$,最多有$2\cdot 10^5$个数，显然是超了，必须用long long int，int为<strong>4字节</strong>，<strong>long long int为8字节</strong></p><p><strong>原码反码补码</strong>：</p><p><a href="https://blog.csdn.net/u013760665/article/details/98520702">https://blog.csdn.net/u013760665/article/details/98520702</a></p><p><a href="https://blog.csdn.net/afsvsv/article/details/94553228">https://blog.csdn.net/afsvsv/article/details/94553228</a></p><pre class=" language-c"><code class="language-c"><span class="token macro property">#<span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h></span></span>using namespace std<span class="token punctuation">;</span><span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">200005</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//数组稍微开大一点就崩溃了，不知道咋回事</span><span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//freopen("1.txt","r",stdin);</span>    <span class="token keyword">int</span> t<span class="token punctuation">;</span>    cin<span class="token operator">>></span>t<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span>k<span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>t<span class="token operator">--</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        cin<span class="token operator">>></span>n<span class="token operator">>></span>k<span class="token punctuation">;</span>        <span class="token keyword">int</span> a<span class="token punctuation">[</span>maxn<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>i<span class="token operator">&lt;=</span>n<span class="token operator">*</span>k<span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//可以设立一个更大的数组，然后数组从1开始</span>            cin<span class="token operator">>></span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">//从1开始对于本题思维逻辑更清晰 </span>        <span class="token punctuation">}</span>         <span class="token keyword">int</span> median<span class="token operator">=</span><span class="token function">ceil</span><span class="token punctuation">(</span>n<span class="token operator">/</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//ceil对于浮点数</span>        <span class="token keyword">int</span> l1<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//两个指针不一定就是真的指针，只是两个int值用来标定位置</span>        <span class="token keyword">int</span> l2<span class="token operator">=</span>n<span class="token operator">*</span>k<span class="token punctuation">;</span>        <span class="token keyword">long</span> <span class="token keyword">long</span> <span class="token keyword">int</span> ans<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>l1<span class="token operator">&lt;=</span>l2<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment" spellcheck="true">//两个指针碰头说明找完了</span>            l2<span class="token operator">-</span><span class="token operator">=</span>n<span class="token operator">-</span>median<span class="token punctuation">;</span><span class="token comment" spellcheck="true">//擦去不是说真的把数组删除了，我们之后不看他他对于我们来看就跟删去一样！</span>            ans<span class="token operator">+</span><span class="token operator">=</span>a<span class="token punctuation">[</span>l2<span class="token punctuation">]</span><span class="token punctuation">;</span>            l2<span class="token operator">-</span><span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>            l1<span class="token operator">+</span><span class="token operator">=</span>median<span class="token number">-1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        cout<span class="token operator">&lt;&lt;</span>ans<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> oj </category>
          
      </categories>
      
      
        <tags>
            
            <tag> codeforces </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器使用</title>
      <link href="fu-wu-qi-shi-yong/"/>
      <url>fu-wu-qi-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>linux教程：<a href="http://c.biancheng.net/view/4017.html">http://c.biancheng.net/view/4017.html</a></p><p>unzip -d des src 解压到指定目录</p><p>df -h 查看磁盘空间大小</p><h4 id="linux服务器安装conda？"><a href="#linux服务器安装conda？" class="headerlink" title="linux服务器安装conda？"></a>linux服务器安装conda？</h4><p>CSDN：<a href="https://blog.csdn.net/weixin_40258579/article/details/85001218?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/weixin_40258579/article/details/85001218?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><p>官方文档：<a href="https://docs.anaconda.com/anaconda/install/linux/">https://docs.anaconda.com/anaconda/install/linux/</a></p><p>source ~/.bashrc启用conda</p><h4 id="安装pytorch"><a href="#安装pytorch" class="headerlink" title="安装pytorch?"></a>安装pytorch?</h4><p><a href="https://blog.csdn.net/xzy5210123/article/details/107237037?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/xzy5210123/article/details/107237037?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><p>建议安装下面这个版本的pytorch,不然咱们实验室的cuda用不了</p><p><a href="https://discuss.pytorch.org/t/rtx-3000-support/98158">https://discuss.pytorch.org/t/rtx-3000-support/98158</a></p><h4 id="python版本更改？"><a href="#python版本更改？" class="headerlink" title="python版本更改？"></a>python版本更改？</h4><p>还是有大佬的！<a href="https://www.cnblogs.com/chenhuabin/p/10718471.html">https://www.cnblogs.com/chenhuabin/p/10718471.html</a></p><p><img src="/fu-wu-qi-shi-yong/image-20201113190611958.png" alt="这一步是重点"></p><h4 id="Xshell复制粘贴设置"><a href="#Xshell复制粘贴设置" class="headerlink" title="Xshell复制粘贴设置"></a>Xshell复制粘贴设置</h4><p><a href="https://www.cnblogs.com/sxdcgaq8080/p/10025759.html">https://www.cnblogs.com/sxdcgaq8080/p/10025759.html</a></p><h4 id="jupyter配置？"><a href="#jupyter配置？" class="headerlink" title="jupyter配置？"></a>jupyter配置？</h4><p>首先，安装jupyter</p><pre><code>pip install jupyter  </code></pre><p>生成jupyter配置文件</p><pre><code>jupyter notebook --generate-config</code></pre><p>打开ipython，生成密码：</p><pre><code># ipythonIn [1]:  from notebook.auth import passwdIn [2]: passwd()</code></pre><p>会让输入两次密码，输入完成后 复制生成的 秘钥，后面会用到，秘钥带上sha1</p><p>修改配置文件：vi中查找 <a href="https://www.cnblogs.com/actively/p/13023292.html">https://www.cnblogs.com/actively/p/13023292.html</a></p><pre><code>vi  /username/.jupyter/jupyter_notebook_config.py    #改几个地方：c.NotebookApp.ip = 'localhost'  #一定要把注释的#号去掉c.NotebookApp.port = 10001                    即对外提供访问的端口c.NotebookApp.open_browser = False            False即启动不打开浏览器c.NotebookApp.password = u'sha1:XXXXX'   这个就是上面生成的秘钥c.NotebookApp.notebook_dir = u'workplace' 即设置jupyter启动后默认的根目录，这个文件夹要自己创建</code></pre><p>然后打开xshell，文件-&gt;当前会话属性-&gt;隧道-&gt;添加 #端口号可以自己设置别的</p><p><img src="/fu-wu-qi-shi-yong/image-20201113093744564.png" alt="隧道属性"></p><p>然后打开jupyter</p><pre><code>jupyter notebook</code></pre><p>然后在windows上打开localhost:10001,就能在windows上使用linux的jupyter notebook</p><h4 id="导入Cuda："><a href="#导入Cuda：" class="headerlink" title="导入Cuda："></a>导入Cuda：</h4><p>对于我们实验室，需要在bashrc中导入</p><pre><code>export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/usr/local/cuda/lib64export PATH=$PATH:/usr/local/cuda/binexport CUDA_HOME=/usr/local/cuda</code></pre><p>然后source .bashrc，然后可以运行nvcc -V查看版本来检查是否正确</p><p>bashrc介绍：<a href="https://blog.csdn.net/qq_16403141/article/details/77987935?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param">https://blog.csdn.net/qq_16403141/article/details/77987935?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-2.channel_param</a></p><p>history查看历史命令</p><h4 id="后台使用jupyter"><a href="#后台使用jupyter" class="headerlink" title="后台使用jupyter"></a>后台使用jupyter</h4><p>nohup一定要删进程 </p><p>ps -aux | grep jupyter 查找jupyter命令</p><p>教程：<a href="https://blog.csdn.net/donaldsy/article/details/96350061">https://blog.csdn.net/donaldsy/article/details/96350061</a></p><h4 id="opencv安装"><a href="#opencv安装" class="headerlink" title="opencv安装"></a>opencv安装</h4><p><a href="https://www.cnblogs.com/thewaytotheway/p/12847260.html">https://www.cnblogs.com/thewaytotheway/p/12847260.html</a></p><h4 id="tensorflow安装"><a href="#tensorflow安装" class="headerlink" title="tensorflow安装"></a>tensorflow安装</h4><p>pip install tensorflow安装的是CPU版本</p><p>pip install tensorflow-gpu 安装的是gpu版本</p><p><a href="%E8%BF%99%E4%B8%AA%E5%8D%9A%E5%AE%A2%E5%A4%A7%E4%BD%ACtql">https://blog.csdn.net/china_xin1/article/details/109824882</a> 显卡3090只支持CUDA11</p><p>所以要 pip install tf-nightly-gpu   尝新版</p><h4 id="查看服务器使用情况"><a href="#查看服务器使用情况" class="headerlink" title="查看服务器使用情况"></a>查看服务器使用情况</h4><p>查看GPU使用情况   watch -n 5 nvidia-smi </p><p>nvcc -V查看当前cuda版本</p><p><a href="https://blog.csdn.net/AlbenXie/article/details/72885951">查看CPU使用情况</a>       top -bn 1 -i -c</p><h4 id="bashrc"><a href="#bashrc" class="headerlink" title=".bashrc"></a>.bashrc</h4><p><a href="https://www.cnblogs.com/midworld/p/11006967.html">https://www.cnblogs.com/midworld/p/11006967.html</a>  保存个性化设置，环境变量等    </p><h4 id="查找文件"><a href="#查找文件" class="headerlink" title="查找文件"></a>查找文件</h4><p><a href="https://www.linuxprobe.com/linux-jar.html">https://www.linuxprobe.com/linux-jar.html</a>   find -name 文件</p>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Matlab</title>
      <link href="matlab/"/>
      <url>matlab/</url>
      
        <content type="html"><![CDATA[<p>教程：<a href="https://www.w3cschool.cn/matlab/">https://www.w3cschool.cn/matlab/</a></p><p>MATLAB Api：<a href="https://www.mathworks.com/help/">https://www.mathworks.com/help/</a></p><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p><strong>matlab数组下标从1开始</strong></p><pre class=" language-matlab"><code class="language-matlab"><span class="token function">class</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%显示数据类型</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%查看各矩阵维度</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%返回最大数组维度的长度</span>X <span class="token operator">=</span> <span class="token function">zeros</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>L <span class="token operator">=</span> <span class="token function">length</span><span class="token punctuation">(</span>X<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%输出9</span><span class="token comment" spellcheck="true">%异常检测</span><span class="token keyword">try</span>    <span class="token punctuation">[</span>C<span class="token punctuation">,</span>scores<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">semanticseg</span><span class="token punctuation">(</span>I<span class="token punctuation">,</span>net<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">catch</span>    <span class="token keyword">continue</span><span class="token punctuation">;</span><span class="token keyword">end</span><span class="token comment" spellcheck="true">%循环</span><span class="token keyword">for</span> k <span class="token operator">=</span> <span class="token number">1</span><span class="token operator">:</span><span class="token function">length</span><span class="token punctuation">(</span>imagepath<span class="token punctuation">)</span>    imagepath<span class="token punctuation">{</span>k<span class="token punctuation">}</span><span class="token operator">=</span><span class="token punctuation">[</span>imagepath<span class="token punctuation">{</span>k<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">'.jpg'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">end</span></code></pre><p>single 单精度数值数据  double 双精度数值数据 </p><p><strong>Cell Array 元胞数组</strong></p><pre class=" language-matlab"><code class="language-matlab">C <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'one'</span><span class="token punctuation">,</span> <span class="token string">'two'</span><span class="token punctuation">,</span> <span class="token string">'three'</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%创建元胞数组</span>     <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span><span class="token punctuation">;</span>emptyCell<span class="token operator">=</span><span class="token function">cell</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">%cell函数创建元胞数组</span>upperLeft<span class="token operator">=</span><span class="token function">C</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">%圆括号索引</span>imagepath<span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token operator">=</span><span class="token string">'45'</span><span class="token comment" spellcheck="true">%这个只能大括号，圆括号就是类型赋值有问题</span></code></pre><p><strong>categorical 字符数组</strong></p><p>从字符矢量创建分类数组</p><pre class=" language-matlab"><code class="language-matlab">A <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">'r'</span> <span class="token string">'b'</span> <span class="token string">'g'</span><span class="token punctuation">;</span> <span class="token string">'g'</span> <span class="token string">'r'</span> <span class="token string">'b'</span><span class="token punctuation">;</span> <span class="token string">'b'</span> <span class="token string">'r'</span> <span class="token string">'g'</span><span class="token punctuation">}</span>B <span class="token operator">=</span> <span class="token function">categorical</span><span class="token punctuation">(</span>A<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%创建分类数组</span><span class="token function">categories</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%显示B的类别</span><span class="token function">class</span><span class="token punctuation">(</span>B<span class="token punctuation">)</span><span class="token comment" spellcheck="true">%显示B的数据类型   就是‘categorical’</span></code></pre><h4 id="文件和文件夹"><a href="#文件和文件夹" class="headerlink" title="文件和文件夹"></a>文件和文件夹</h4><p><code>fullfile(filepart1,...,filepartN)</code>从各个部分构建完整文件名 有点类似os.path.join 还会根据平台改变文件分隔符，创建多个文件路径的话会返回元胞数组</p><pre class=" language-matlab"><code class="language-matlab">f <span class="token operator">=</span> <span class="token function">fullfile</span><span class="token punctuation">(</span><span class="token string">'c:\'</span><span class="token punctuation">,</span><span class="token string">'myfiles'</span><span class="token punctuation">,</span><span class="token string">'matlab'</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token string">'myfile1.m'</span><span class="token punctuation">;</span><span class="token string">'myfile2.m'</span><span class="token punctuation">}</span><span class="token punctuation">)</span>f <span class="token operator">=</span>  <span class="token number">2</span>×<span class="token number">1</span> cell array    <span class="token string">'c:\myfiles\matlab\myfile1.m'</span>    <span class="token string">'c:\myfiles\matlab\myfile2.m'</span></code></pre><p><code>textread</code></p><h4 id="百分号"><a href="#百分号" class="headerlink" title="百分号"></a>百分号</h4><p>双百分号%%在matlab代码中的作用是将代码分块，上下两个%%之间的部分作为一块，在运行代码的时候可以分块运行，查看每一块代码的运行情况。常用于调试程序。</p><p>单百分号%是注释   %{   }%是多行注释 注释快捷键CTRL+R 取消CTRL+T</p><h4 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h4><p><code>imread()</code>读取图像</p><p>figure创建一个画板 <code>imshow()</code>展示图像</p><p><strong>imageDatastore</strong> </p><p>如果一个图像文件集合中的每个图像可以单独放入内存，但整个集合不一定能放入内存，则可以使用 <code>ImageDatastore</code> 对象来管理。您可以使用 <code>imageDatastore</code> 函数创建 <code>ImageDatastore</code> 对象，指定其属性，然后使用对象函数导入和处理数据。</p><p><code>imds = imageDatastore(location)</code>根据 <code>location</code> 指定的图像数据集合创建一个数据存储 </p><h4 id="深度学习入门之旅："><a href="#深度学习入门之旅：" class="headerlink" title="深度学习入门之旅："></a>深度学习入门之旅：</h4><p><a href="https://www.pianshen.com/article/71481644395/">https://www.pianshen.com/article/71481644395/</a></p><h4 id="SeriesNetwork"><a href="#SeriesNetwork" class="headerlink" title="SeriesNetwork"></a>SeriesNetwork</h4><p>串联网络是一种用于深度学习的神经网络，层次化排列。它有一个单一的输入层和一个单一的输出层</p><h4 id="DAGNetwork"><a href="#DAGNetwork" class="headerlink" title="DAGNetwork"></a>DAGNetwork</h4><p><a href="https://blog.csdn.net/weixin_43687366/article/details/102557729">DAG入门之旅</a></p><p>DAG网络是用于深度学习的神经网络，其中的层为有向无环图。各层有来自多个层的输入和到多个层的输出。DAGNetwork对象具有单个输入层和单个输出层。</p><p>lgraph.Connections 展示层的连接</p><p>lgraph.Layers 展示层</p><p>figure  plot(lgraph)把网络图形画出来</p>]]></content>
      
      
      <categories>
          
          <category> Matlab </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Matlab </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python学习</title>
      <link href="python-xue-xi/"/>
      <url>python-xue-xi/</url>
      
        <content type="html"><![CDATA[<p>教程cookbook:<a href="https://python3-cookbook.readthedocs.io/zh_CN/latest/preface.html">https://python3-cookbook.readthedocs.io/zh_CN/latest/preface.html</a></p><h4 id="格式化输出，文字和数字等混合输出时使用！"><a href="#格式化输出，文字和数字等混合输出时使用！" class="headerlink" title="格式化输出，文字和数字等混合输出时使用！"></a>格式化输出，文字和数字等混合输出时使用！</h4><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#第一种</span><span class="token string">"Skipping {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#第二种</span> <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">'[%d, %5d] loss: %.3f'</span> <span class="token operator">%</span> <span class="token punctuation">(</span>epoch <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> running_loss <span class="token operator">/</span> <span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#%5d %5s输出站5个字符宽度，不足补足   %.3f表示保留三位小数</span></code></pre><h4 id="文件读取输出"><a href="#文件读取输出" class="headerlink" title="文件读取输出"></a>文件读取输出</h4><p><a href="https://www.cnblogs.com/ymjyqsx/p/6554817.html">https://www.cnblogs.com/ymjyqsx/p/6554817.html</a></p><p>with open as f 为了保证无论是否出错都能正确地关闭文件</p><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"locs.txt"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#f.write(fname+"\n")</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#每个line都是str</span>        linelist<span class="token operator">=</span>line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#字符串切割</span></code></pre><p>split():str.split(str=””, num=string.count(str))</p><p>str –分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。</p><p>num – 分割次数。默认为 -1, 即分隔所有。</p><p>返回分割后的字符串列表。</p><p><code>files = file.read().splitlines()</code></p><p>file.read 默认读取全部</p><p>splitlines() 按照行界符(‘\r’, ‘\r\n’, \n’等)分隔，返回一个包含各行作为元素的列表，默认不包含行界符。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">'mytest.txt'</span><span class="token punctuation">,</span><span class="token string">'w'</span><span class="token punctuation">,</span>encoding<span class="token operator">=</span><span class="token string">'utf-8'</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span><span class="token comment" spellcheck="true">#w是覆盖，a是追加</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        f<span class="token punctuation">.</span>write<span class="token punctuation">(</span>a<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">+</span><span class="token string">'\n'</span><span class="token punctuation">)</span>   </code></pre><h4 id="进度条"><a href="#进度条" class="headerlink" title="进度条"></a>进度条</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm<span class="token keyword">for</span> fname <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span>os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>input_dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span></code></pre><h4 id="绝对路径和相对路径"><a href="#绝对路径和相对路径" class="headerlink" title="绝对路径和相对路径"></a>绝对路径和相对路径</h4><p><a href="https://blog.csdn.net/databatman/article/details/49453953">https://blog.csdn.net/databatman/article/details/49453953</a></p><h4 id="strip"><a href="#strip" class="headerlink" title="strip()"></a>strip()</h4><p><strong>strip()</strong> 处理的时候，如果不带参数，默认是清除两边的空白符，例如：<strong>\n</strong>, <strong>\r</strong>, <strong>\t</strong>, <strong>‘ ‘</strong>)。</p><pre class=" language-python"><code class="language-python">str <span class="token operator">=</span> <span class="token string">'123@163.com'</span><span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">'132'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#@163.com</span>str <span class="token operator">=</span> <span class="token string">'123@163.com'</span><span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">'23'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#123@163.com</span></code></pre><h4 id="with关键字"><a href="#with关键字" class="headerlink" title="with关键字"></a>with关键字</h4><p><a href="https://www.cnblogs.com/xiaxiaoxu/p/9747551.html">https://www.cnblogs.com/xiaxiaoxu/p/9747551.html</a></p><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><p><a href="https://blog.csdn.net/yilulvxing/article/details/85374142">https://blog.csdn.net/yilulvxing/article/details/85374142</a></p><p>就是把父类全部拿过来，你有想改的，你再自己改好吧，你重写了父类的方法，还想用父类的方法，怎么办？利用super()函数</p><p>如果自己也定义了__ <strong>init__</strong> 方法,那么父类的属性是不能直接调用的,可以在 子类的 <strong>init__中调用一下父类的 __init</strong> 方法,这样就可以调用了</p><h4 id="super关键字"><a href="#super关键字" class="headerlink" title="super关键字"></a>super关键字</h4><p><a href="https://www.runoob.com/w3cnote/python-super-detail-intro.html">https://www.runoob.com/w3cnote/python-super-detail-intro.html</a></p><p>super可以传入子类的方法和对象，</p><p><strong>super().add(m)</strong> 调用父类方法 <strong>def add(self, m)</strong> 时, 此时父类中 <strong>self</strong> 并不是父类的实例而是子类的实例, 所以 <strong>b.add(2)</strong> 之后的结果是 <strong>5</strong> 而不是 <strong>4</strong></p><h4 id="enumerate"><a href="#enumerate" class="headerlink" title="enumerate()"></a>enumerate()</h4><p>enumerate() 函数用于将**一个可遍历的数据对象(如列表、元组或字符串)**组合为一个索引序列，同时列出数据和数据下标，一般用在 for 循环当中。</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> seasons <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'Spring'</span><span class="token punctuation">,</span> <span class="token string">'Summer'</span><span class="token punctuation">,</span> <span class="token string">'Fall'</span><span class="token punctuation">,</span> <span class="token string">'Winter'</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>enumerate<span class="token punctuation">(</span>seasons<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">'Spring'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Summer'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Fall'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Winter'</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token operator">>></span><span class="token operator">></span> list<span class="token punctuation">(</span>enumerate<span class="token punctuation">(</span>seasons<span class="token punctuation">,</span> start<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span>       <span class="token comment" spellcheck="true"># 小标从 1 开始</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">'Spring'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">'Summer'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">'Fall'</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token string">'Winter'</span><span class="token punctuation">)</span><span class="token punctuation">]</span></code></pre><p><strong>print 默认输出</strong>是换行的，如果要实现不换行需要在变量末尾加上 **end=””**：</p><p>True和False可以直接当成0和1来用</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token boolean">True</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> <span class="token boolean">False</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token boolean">True</span><span class="token operator">>></span><span class="token operator">></span> <span class="token boolean">True</span> <span class="token operator">+</span> <span class="token boolean">False</span> <span class="token operator">+</span> <span class="token number">20</span><span class="token number">21</span></code></pre><h4 id="dir"><a href="#dir" class="headerlink" title="dir()"></a>dir()</h4><p>dir函数可以返回参数的属性、方法和列表</p><h4 id="argparse"><a href="#argparse" class="headerlink" title="argparse"></a>argparse</h4><p>教程 <a href="https://geek-docs.com/python/python-tutorial/python-argparse.html">https://geek-docs.com/python/python-tutorial/python-argparse.html</a></p><p>这篇写的好 <a href="https://vra.github.io/2017/12/02/argparse-usage/">https://vra.github.io/2017/12/02/argparse-usage/</a></p><p>add了这个 –name，就可以.name调用</p><p>arg.dataset   dataset之前没定义  根据实验，这个操作是给arg添加了一个新属性dataset</p><p> json 看教程</p><p><strong>下面的教程很重要，通过修改args来不用命令行使用！</strong></p><p><a href="https://stackoom.com/question/3RVtX/%E8%B0%83%E8%AF%95%E6%97%B6%E6%A8%A1%E6%8B%9Fargparse%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%BE%93%E5%85%A5">https://stackoom.com/question/3RVtX/%E8%B0%83%E8%AF%95%E6%97%B6%E6%A8%A1%E6%8B%9Fargparse%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%8F%82%E6%95%B0%E8%BE%93%E5%85%A5</a></p><p><img src="/python-xue-xi/image-20201116220928895.png" alt="首选方式"></p><h4 id="os"><a href="#os" class="headerlink" title="os"></a>os</h4><p><a href="https://www.jianshu.com/p/86f88b3d7efd">https://www.jianshu.com/p/86f88b3d7efd</a></p><p>os.path.join</p><pre><code>import osa=os.path.join("datasets", "lifesat", "")print(a)#datasets\lifesat\</code></pre><p>os.makedirs（）:递归的创建文件目录</p><p>exist_ok:是否在目录存在时触发异常。如果exist_ok为<strong>False</strong>（默认值），则在目标目录已存在的情况下<strong>触发</strong>FileExistsError异常；如果exist_ok为<strong>True</strong>，则在目标目录已存在的情况下<strong>不会触发</strong>FileExistsError异常。</p><p><code>os.listdir(文件夹名字)</code>列出文件夹下所有的文件名</p><h4 id="shutil"><a href="#shutil" class="headerlink" title="shutil"></a>shutil</h4><p><a href="https://liujiangblog.com/course/python/61">https://liujiangblog.com/course/python/61</a></p><p><strong>shutil模块是对os模块的补充，主要针对文件的拷贝、删除、移动、压缩和解压操作。</strong></p><h4 id="sys"><a href="#sys" class="headerlink" title="sys"></a>sys</h4><p><a href="https://www.liujiangblog.com/course/python/54">https://www.liujiangblog.com/course/python/54</a></p><p><strong>sys模块主要是针对与Python解释器相关的变量和方法，不是主机操作系统。</strong></p><h4 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h4><p><code>def add_to_graph(self, dataset) -&gt; tf.data.Dataset: 箭头的作用是给函数添加注解，用来返回值的数据类型</code></p><p><code>def get_filters_count(level: int, initial_filters: int) -&gt; int:</code>冒号的作用是说参数的数据类型</p><h4 id="list"><a href="#list" class="headerlink" title="list"></a>list</h4><p><code>list（）函数返回一个新的列表，b=list（a），b和a不共享</code> </p><p><code>list.append()</code> 向列表添加元素</p><h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>pop   删除字典给定键 key 所对应的值，返回值为被删除的值。key值必须给出。 否则，返回default值。</p><h4 id="py文件运行"><a href="#py文件运行" class="headerlink" title="py文件运行"></a>py文件运行</h4><p>在jupyter notebook中，运行 %run name.py</p><h4 id="return-self"><a href="#return-self" class="headerlink" title="return self"></a>return self</h4><p>其实就是返回自身实例，用于链式调用  <a href="https://blog.csdn.net/jclian91/article/details/81238782">看这篇教程</a></p><h4 id="可变长度参数"><a href="#可变长度参数" class="headerlink" title="可变长度参数"></a>可变长度参数</h4><p>*args将参数打包成tuple给函数体调用</p><p>**kwargs打包关键字参数成dict给函数体调用</p><p>注意点：参数arg、<em>args、**kwargs三个参数的位置必须是一定的。必须是(arg,<em>args,</em></em>kwargs)这个顺序，否则程序会报错。</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">function</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span><span class="token operator">*</span>args<span class="token punctuation">,</span><span class="token operator">**</span>kwargs<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>arg<span class="token punctuation">,</span>args<span class="token punctuation">,</span>kwargs<span class="token punctuation">)</span>function<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span>a<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">,</span> b<span class="token operator">=</span><span class="token number">2</span><span class="token punctuation">,</span> c<span class="token operator">=</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#6 (7,8,9) {'c':3,'a':1,'b':2}</span></code></pre><h4 id="装饰器和-符号"><a href="#装饰器和-符号" class="headerlink" title="装饰器和@符号"></a>装饰器和@符号</h4><p>python中的函数可以像普通变量一样当做参数传递给另外一个函数</p><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">bar</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    func<span class="token punctuation">(</span><span class="token punctuation">)</span>bar<span class="token punctuation">(</span>foo<span class="token punctuation">)</span></code></pre><p>具体看这一篇：<a href="https://gohom.win/2015/10/25/pyDecorator/">https://gohom.win/2015/10/25/pyDecorator/</a></p><p>这一篇讲的更清楚<a href="https://foofish.net/python-decorator.html">https://foofish.net/python-decorator.html</a></p><p>简单来说就是复合函数，概括的讲，装饰器的作用就是为已经存在的对象添加额外的功能</p><p>内置的@property和@*.setter，其实认真看完实例就明白了，就相当于python的get和set方法，关于这两个内置装饰器可以看这个：<a href="https://www.liaoxuefeng.com/wiki/897692888725344/923030547069856">https://www.liaoxuefeng.com/wiki/897692888725344/923030547069856</a></p><p>看这段代码：</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> tensorflow <span class="token keyword">as</span> tf<span class="token keyword">class</span> <span class="token class-name">D</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dataset_dir<span class="token punctuation">:</span> str<span class="token punctuation">,</span> batch_size<span class="token punctuation">:</span> int<span class="token punctuation">,</span>train_dataset<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>dataset_dir <span class="token operator">=</span> dataset_dir        self<span class="token punctuation">.</span>batch_size <span class="token operator">=</span> batch_size        self<span class="token punctuation">.</span>val_dataset <span class="token operator">=</span> None        self<span class="token punctuation">.</span>train_dataset <span class="token operator">=</span> train_dataset<span class="token comment" spellcheck="true">#这里调用的set方法</span>        self<span class="token punctuation">.</span>test_dataset <span class="token operator">=</span> None    <span class="token comment" spellcheck="true">#train_dataset get set 方法</span>    @property    <span class="token keyword">def</span> <span class="token function">train_dataset</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> <span class="token keyword">print</span><span class="token punctuation">(</span>self<span class="token punctuation">.</span>__train_dataset<span class="token punctuation">)</span>    @train_dataset<span class="token punctuation">.</span>setter    <span class="token keyword">def</span> <span class="token function">train_dataset</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>__train_dataset <span class="token operator">=</span> dataset <span class="token comment" spellcheck="true">#这里新定义了一个属性</span>        <span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"!!!!"</span><span class="token punctuation">)</span>d<span class="token operator">=</span>D<span class="token punctuation">(</span><span class="token string">"asdf"</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>d<span class="token punctuation">.</span>train_dataset<span class="token comment" spellcheck="true">#！！！！</span><span class="token comment" spellcheck="true">#2</span></code></pre><h4 id="name"><a href="#name" class="headerlink" title="__name__"></a>__name__</h4><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">get_fun_name</span><span class="token punctuation">(</span>func<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">return</span> func<span class="token punctuation">.</span>__name__<span class="token comment" spellcheck="true">#返回的就是函数的名字</span><span class="token keyword">def</span> <span class="token function">say_hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">pass</span><span class="token keyword">def</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token comment" spellcheck="true"># 看起来没有用处呀</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>get_fun_name<span class="token punctuation">(</span>say_hello<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 那么看下面</span>    haha <span class="token operator">=</span> say_hello    hahaha <span class="token operator">=</span> haha    <span class="token comment" spellcheck="true"># 请问 hahaha 到底是啥？</span>    <span class="token keyword">print</span><span class="token punctuation">(</span>get_fun_name<span class="token punctuation">(</span>hahaha<span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true"># 我的认为 __name__ 可以忽略外表，直达本质。</span><span class="token keyword">if</span> __name__ <span class="token operator">==</span> <span class="token string">'__main__'</span><span class="token punctuation">:</span>    main<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">/</span>home<span class="token operator">/</span>coder<span class="token operator">/</span>anaconda3<span class="token operator">/</span>envs<span class="token operator">/</span>py37<span class="token operator">/</span>bin<span class="token operator">/</span>python <span class="token operator">/</span>home<span class="token operator">/</span>coder<span class="token operator">/</span>PycharmProjects<span class="token operator">/</span>Base<span class="token operator">/</span>demo<span class="token punctuation">.</span>pysay_hellosay_helloProcess finished <span class="token keyword">with</span> exit code <span class="token number">0</span></code></pre><h4 id="assert"><a href="#assert" class="headerlink" title="assert"></a>assert</h4><p>Python assert（断言）用于判断一个表达式，在表达式条件为 false 的时候触发异常。</p><h4 id="python字符串前加u-r-b-f"><a href="#python字符串前加u-r-b-f" class="headerlink" title="python字符串前加u,r,b,f"></a>python字符串前加u,r,b,f</h4><p><a href="https://www.cnblogs.com/walo/p/10608436.html">https://www.cnblogs.com/walo/p/10608436.html</a></p><h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><p><a href="https://blog.csdn.net/jeffery0207/article/details/93734942">https://blog.csdn.net/jeffery0207/article/details/93734942</a></p><h4 id="多个返回值"><a href="#多个返回值" class="headerlink" title="多个返回值"></a>多个返回值</h4><p>返回的是一个tuple</p><h4 id="skimage"><a href="#skimage" class="headerlink" title="skimage"></a>skimage</h4>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>pytorch学习</title>
      <link href="pytorch-xue-xi/"/>
      <url>pytorch-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Pytorch"><a href="#Pytorch" class="headerlink" title="Pytorch"></a>Pytorch</h2><p>handbook：<a href="https://github.com/zergtant/pytorch-handbook">https://github.com/zergtant/pytorch-handbook</a></p><p>pytorch API:<a href="https://pytorch.org/docs/stable/index.html">https://pytorch.org/docs/stable/index.html</a></p><p>类似例程：<a href="https://github.com/yunjey/pytorch-tutorial">https://github.com/yunjey/pytorch-tutorial</a></p><p>Docs：<a href="https://github.com/fendouai/PyTorchDocs">https://github.com/fendouai/PyTorchDocs</a></p><h4 id="基本知识"><a href="#基本知识" class="headerlink" title="基本知识"></a>基本知识</h4><p>torch运用就和np一样</p><p><strong>torch.tensor</strong></p><p>不是基本数据类型如int，float，string等，而是引用数据类型</p><p>JAVA中的概念：<a href="https://www.cnblogs.com/maskwolf/p/9972982.html">https://www.cnblogs.com/maskwolf/p/9972982.html</a>   </p><p>是在类中封装好的。所以肯定相应操作比如运算符等人家已经给你重载了，所以不用想的太多</p><p>两个tensor<strong>相加如果是同维度</strong>的话，就直接对应元素相加</p><p><strong>“_”结尾的操作</strong></p><p>会用结果替换原变量，例如y.add_(x)!</p><p><strong>x.view（-1,8）</strong>:这个-1是指从其他维度推断！</p><p><strong>torch.Tensor.item</strong>：获取单个值，否则就用tolist()</p><p><strong>torch.Tensor.tolist()</strong>:果然有向基本类型转化的函数</p><p><strong>pytorch的通道顺序是：NCHW</strong></p><p>即可以用size()也可以用numpy的shape</p><p><img src="/pytorch-xue-xi/image-20201113101903090.png" alt="标量、向量和矩阵"></p><p>torch.tensor(3.14)这是标量   torch.tensor([3.14])这是向量，判断是几维张量主要是<strong>看有几个中括号</strong></p><p>tensor转numpy    <code>numpy_a = a.numpy()</code>   numpy转tensor  <code>torch_a=torch.from_numpy(numpy_a)</code></p><p><strong>Tensor和numpy对象共享内存，转换很快，但这也意味着，如果其中一个变了，另一个也会变</strong></p><p>一个简单的网络最基本的步骤就是<strong>前向，损失，反向，更新</strong></p><p><strong>parameters？</strong></p><p>输出的是一个w，一个b！别忘了b！</p><h4 id="Conv2D（）"><a href="#Conv2D（）" class="headerlink" title="Conv2D（）:"></a>Conv2D（）:</h4><p>教程：<a href="https://www.jianshu.com/p/45a26d278473">https://www.jianshu.com/p/45a26d278473</a></p><p>Conv1D（）和Conv2D（）写的很好，卷积层和线性层在__init__里面，而激活和池化在forward函数里面。</p><p>卷积核的规模就是kernel_size x input_channel x output_channel</p><p>Pytorch池化操作的步长默认与池化卷积核的大小一样，池化一般不考虑overlap</p><p>在全连接层之前通过view函数将其改为一维向量</p><p>默认：步长为1 没有填充，空洞值为1，gruops=1，有偏置，填充补0</p><p>torch.nn 只支持小批量输入。整个 torch.nn 包都只支持小批量样本，而不支持单个样本。 例如，nn.Conv2d 接受一个4维的张量， 每一维分别是sSamples * nChannels * Height * Width（样本数<em>通道数</em>高*宽）。 如果你有单个样本，<strong>只需使用 input.unsqueeze(0) 来添加其它的维数</strong></p><p>接受$(N,C_{in},H,W)$,输出$(N,C_{out},H_{out},W_{out}$)</p><h4 id="CNN的反向传播"><a href="#CNN的反向传播" class="headerlink" title="CNN的反向传播"></a>CNN的反向传播</h4><p>教程:<a href="https://zhuanlan.zhihu.com/p/61898234">https://zhuanlan.zhihu.com/p/61898234</a></p><h4 id="torch-rand"><a href="#torch-rand" class="headerlink" title="torch.rand()"></a>torch.rand()</h4><p>rand从(0,1)的均匀分布中随机抽样，randn从标准正态分布随机抽样，torch.normal(mean,std)  正太分布随机抽样  torch.linspace()线性间距向量  ones初始化为1   zeros初始化为0  eye初始化为单位矩阵</p><h4 id="transforms的22个方法"><a href="#transforms的22个方法" class="headerlink" title="transforms的22个方法"></a>transforms的22个方法</h4><p><a href="https://blog.csdn.net/qq_38410428/article/details/94719553">https://blog.csdn.net/qq_38410428/article/details/94719553</a></p><p>Normalize参数解惑<a href="https://blog.csdn.net/xys430381_1/article/details/85724668">https://blog.csdn.net/xys430381_1/article/details/85724668</a></p><h4 id="torchvision-utils-make-grid"><a href="#torchvision-utils-make-grid" class="headerlink" title="torchvision.utils.make_grid()"></a>torchvision.utils.make_grid()</h4><p>把若干图像拼成一副图像来显示<a href="https://blog.csdn.net/u012343179/article/details/83007296">https://blog.csdn.net/u012343179/article/details/83007296</a></p><h4 id="torch-max"><a href="#torch-max" class="headerlink" title="torch.max()"></a>torch.max()</h4><p>_, predicted = torch.max(outputs, 1)</p><p>outputs是数据Tensor，1表示求第一维度上的最大值</p><p>_是不要了  torch.max（）的返回值分两部分，分别是values和indices</p><p><strong>torch.utils.data.DataLoader</strong> </p><p>dataset就是既包括数据又包括标签的，上面的函数数据类型就是torch.utils.data.dataloader.DataLoader</p><p>for data in testloader: 这里的data就是一个batch的数据</p><p><a href="https://www.cnblogs.com/demo-deng/p/10623334.html">https://www.cnblogs.com/demo-deng/p/10623334.html</a></p><p>下面是一个介绍，其中TensorDataset是将tensor包装成Dataset类</p><p><a href="https://blog.csdn.net/zw__chen/article/details/82806900?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/zw__chen/article/details/82806900?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><p>下面这篇讲得很好：<a href="https://blog.csdn.net/qq_27825451/article/details/96130126">https://blog.csdn.net/qq_27825451/article/details/96130126</a></p><pre class=" language-python"><code class="language-python"><span class="token comment" spellcheck="true">#Dataset的抽象父类</span><span class="token keyword">class</span> <span class="token class-name">Dataset</span><span class="token punctuation">(</span>object<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#必须重写</span>        <span class="token keyword">raise</span> NotImplementedError    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span><span class="token comment" spellcheck="true">#必须重写</span>        <span class="token keyword">raise</span> NotImplementedError    <span class="token keyword">def</span> <span class="token function">__add__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> other<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> ConcatDataset<span class="token punctuation">(</span><span class="token punctuation">[</span>self<span class="token punctuation">,</span> other<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">class</span> <span class="token class-name">RandomDataset</span><span class="token punctuation">(</span>Dataset<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">def</span> <span class="token function">__init__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> size<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">:</span>        self<span class="token punctuation">.</span>len <span class="token operator">=</span> length        self<span class="token punctuation">.</span>data <span class="token operator">=</span> torch<span class="token punctuation">.</span>randn<span class="token punctuation">(</span>length<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这个length就是batch的个数</span>    <span class="token keyword">def</span> <span class="token function">__getitem__</span><span class="token punctuation">(</span>self<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>data<span class="token punctuation">[</span>index<span class="token punctuation">]</span>    <span class="token keyword">def</span> <span class="token function">__len__</span><span class="token punctuation">(</span>self<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> self<span class="token punctuation">.</span>len</code></pre><h4 id="torch-squeeze"><a href="#torch-squeeze" class="headerlink" title="torch.squeeze()"></a>torch.squeeze()</h4><p>For example, if input is of shape:$(A\cdot 1\cdot B \cdot 1\cdot C\cdot 1\cdot D)$ then the out tensor will be of shape:$(A\cdot  B \cdot  C\cdot  D)$ </p><p>如果指定维度的话，那只对该维度去1</p><p><strong>注意</strong>：返回的张量与输入张量共享存储空间，因此改变一个张量的内容将改变另一个张量的内容。</p><p>另外如果对批次batch为1也去掉的话，可能会引发错误。</p><h4 id="求导和网络相关知识"><a href="#求导和网络相关知识" class="headerlink" title="求导和网络相关知识"></a>求导和网络相关知识</h4><p>grad属性保存梯度值，grad_fn保存梯度函数</p><p>nn.functional函数的特点是不具有可学习的参数，$net.parameters()$返回网络可学习的参数</p><pre><code>for name,parameters in net.named_parameters():#可同时返回名字和参数    print(name,':',parameters.size())#conv1.weight : torch.Size([6, 1, 3, 3])#conv1.bias : torch.Size([6])#fc1.weight : torch.Size([10, 1350])#fc1.bias : torch.Size([10])</code></pre><p>forward函数的输入和输出都是Tensor ,在反向传播前，先要将所有参数的梯度清零,如果不清0，计算得到的梯度值会进行累加</p><p><strong>torch.nn只支持mini-batches，不支持一次只输入一个样本，即一次必须是一个batch。</strong></p><h4 id="数据加载相关知识"><a href="#数据加载相关知识" class="headerlink" title="数据加载相关知识"></a>数据加载相关知识</h4><p>Dataset是一个抽象类，为了能够方便的读取，需要将要使用的数据包装为Dataset类。</p><p>torchvision.datasets 下载已经有的数据集</p><p>torchvision.models 获得训练好的模型</p><p>torchvision.transforms 提供了一般的图像转换操作类</p><h4 id="数学相关"><a href="#数学相关" class="headerlink" title="数学相关"></a>数学相关</h4><p>因为pytorch是minibatch加载，所以损失函数求出来就已经做了平均</p><p>nn.L1Loss: $loss(x,class)=\frac{1}{n} \sum|x_i -y_i|$</p><p>nn.NLLLoss:用于多分类的负对数似然损失函数</p><p>nn.MSELoss:均方误差</p><p>nn.CrossEntropyLoss:交叉熵损失函数</p><p>torch.manual_seed() :<a href="https://blog.csdn.net/X_singing/article/details/104447052?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/X_singing/article/details/104447052?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><p>为了保证能够复现，初始随机梯度是固定的</p><h4 id="使用GPU"><a href="#使用GPU" class="headerlink" title="使用GPU"></a>使用GPU</h4><p><strong>CUDA是什么？</strong></p><p><a href="https://blog.csdn.net/u014380165/article/details/77340765">https://blog.csdn.net/u014380165/article/details/77340765</a></p><pre class=" language-python"><code class="language-python">device <span class="token operator">=</span> torch<span class="token punctuation">.</span>device<span class="token punctuation">(</span><span class="token string">"cuda:0"</span> <span class="token keyword">if</span> torch<span class="token punctuation">.</span>cuda<span class="token punctuation">.</span>is_available<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">else</span> <span class="token string">"cpu"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#这一步是设置我们使用的GPU</span><span class="token comment" spellcheck="true"># 确认我们的电脑支持CUDA，然后显示CUDA信息：</span><span class="token keyword">print</span><span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#然后这些方法将递归遍历所有模块并将模块的参数和缓冲区 转换成CUDA张量：</span>net<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#记住：inputs, targets 和 images 也要转换。</span>inputs<span class="token punctuation">,</span> labels <span class="token operator">=</span> inputs<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span><span class="token punctuation">,</span> labels<span class="token punctuation">.</span>to<span class="token punctuation">(</span>device<span class="token punctuation">)</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pytorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>numpy、pandas、matplotlib学习</title>
      <link href="numpy-he-pandas-xue-xi/"/>
      <url>numpy-he-pandas-xue-xi/</url>
      
        <content type="html"><![CDATA[<h2 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h2><p>菜鸟教程：<a href="https://www.runoob.com/numpy/numpy-ndarray-object.html">https://www.runoob.com/numpy/numpy-ndarray-object.html</a></p><p>API:<a href="https://docs.scipy.org/doc/numpy-1.9.0/genindex.html">https://docs.scipy.org/doc/numpy-1.9.0/genindex.html</a></p><p><code>np.array(list)</code>将列表转化为数组</p><p><code>np.std()</code>求标准差</p><p>Python<code>list</code>只能与整数相乘，在这种情况下，将<code>list</code>重复的元素：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">*</span> <span class="token number">3</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span></code></pre><p>如果要进行矢量运算，请<code>numpy.ndarray</code>改用：</p><pre class=" language-python"><code class="language-python"><span class="token operator">>></span><span class="token operator">></span> <span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token operator">>></span><span class="token operator">></span> ar <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token operator">>></span><span class="token operator">></span> ar <span class="token operator">*</span> <span class="token number">3</span>array<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#numpy数组索引</span>pre<span class="token operator">=</span>pre<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token punctuation">:</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token comment" spellcheck="true">#不用三个中括号，只用一个，里面只用一个逗号</span></code></pre><p>numpy广播机制：<a href="https://zhuanlan.zhihu.com/p/60365398">https://zhuanlan.zhihu.com/p/60365398</a></p><p>np.linspace()和np.arrange()一个是样本数量，一个步长</p><p>在jupyter notebook中，可直接调用<code>arr.dtype</code> <code>arr.shape</code>显示相应的属性</p><pre class=" language-python"><code class="language-python">np<span class="token punctuation">.</span>where<span class="token punctuation">(</span>condition<span class="token punctuation">[</span><span class="token punctuation">,</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#返回根据条件从x或y中选择的元素。条件为真，返回x，否则返回y。</span><span class="token comment" spellcheck="true">#&lt;&lt;&lt;a</span><span class="token comment" spellcheck="true">#array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</span><span class="token comment" spellcheck="true">#&lt;&lt;&lt;np.where(a &lt; 5, a, 10*a)</span><span class="token comment" spellcheck="true">#array([ 0,  1,  2,  3,  4, 50, 60, 70, 80, 90])</span>np<span class="token punctuation">.</span>unique<span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#显示np数组中的unique值，还有返回index值等功能</span>np<span class="token punctuation">.</span>ceil<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#向上取整 </span>np<span class="token punctuation">.</span>floor<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#向下取整</span>np<span class="token punctuation">.</span>round<span class="token punctuation">(</span>a<span class="token punctuation">,</span>decimals<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">,</span>out<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token comment" spellcheck="true">#将数组四舍五入到指定的小数上</span></code></pre><h2 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h2><p>教程：<a href="https://www.yiibai.com/pandas/python_pandas_environment_setup.html">https://www.yiibai.com/pandas/python_pandas_environment_setup.html</a></p><p>API:<a href="https://pandas.pydata.org/pandas-docs/stable/reference/index.html">https://pandas.pydata.org/pandas-docs/stable/reference/index.html</a></p><p>将dataframe一行转化为int，astype</p><pre><code>top, right, bottom, left = row[0:].astype(int)</code></pre><p>获取dataframe的行数和列数</p><pre class=" language-python"><code class="language-python">df<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">//</span>行数df<span class="token punctuation">.</span>shape<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">//</span>列数</code></pre><h2 id="Matplotlib"><a href="#Matplotlib" class="headerlink" title="Matplotlib"></a>Matplotlib</h2><p>易百教程：<a href="https://www.yiibai.com/matplotlib">https://www.yiibai.com/matplotlib</a></p><p>API：<a href="https://matplotlib.org/3.3.2/api/index.html">https://matplotlib.org/3.3.2/api/index.html</a></p><p>假如目前只有一个figure1，你再绘图是在它上面不断覆盖的</p><p>分为plt绘图与axes绘图两种方式</p><h4 id="图像处理"><a href="#图像处理" class="headerlink" title="图像处理"></a>图像处理</h4><p><a href="https://www.fontke.com/tool/rgb/800000/">根据RGB  CMYK  HSL  HSV  XYZ 值来查询颜色</a></p><p><code>plt.figure(1)</code>建立一个新的展示图像的画板</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>image <span class="token keyword">as</span> imgplt<span class="token keyword">import</span> matplotlib<span class="token punctuation">.</span>pyplot <span class="token keyword">as</span> pltx <span class="token operator">=</span> imgplt<span class="token punctuation">.</span>imread<span class="token punctuation">(</span><span class="token string">'label.png'</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>imshow<span class="token punctuation">(</span>x<span class="token punctuation">[</span><span class="token number">300</span><span class="token punctuation">:</span><span class="token number">350</span><span class="token punctuation">,</span><span class="token number">150</span><span class="token punctuation">:</span><span class="token number">200</span><span class="token punctuation">]</span><span class="token punctuation">)</span>plt<span class="token punctuation">.</span>show<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#matplotlib显示图像，注意x只用一个[]，不同维度用逗号分割！</span><span class="token comment" spellcheck="true">#imread的返回值是图片数据data，数据类型是class:`numpy.array`。这个图片数据data的维度如下：</span><span class="token comment" spellcheck="true">#- (M, N) 对于灰度级图片</span><span class="token comment" spellcheck="true">#- (M, N, 3) 对于RGB彩色图片.</span><span class="token comment" spellcheck="true">#- (M, N, 4) 对于RGBA彩色图片</span></code></pre><p><code>plt.imsave(文件名,X,format='png')</code>图片的保存</p><pre class=" language-python"><code class="language-python"><span class="token keyword">import</span> numpy <span class="token keyword">as</span> np<span class="token keyword">from</span> PIL <span class="token keyword">import</span> Imageimg <span class="token operator">=</span> Image<span class="token punctuation">.</span>open<span class="token punctuation">(</span><span class="token string">'label.png'</span><span class="token punctuation">)</span>img2 <span class="token operator">=</span> np<span class="token punctuation">.</span>array<span class="token punctuation">(</span>img<span class="token punctuation">)</span>np<span class="token punctuation">.</span>unique<span class="token punctuation">(</span>img2<span class="token punctuation">)</span></code></pre><p>PIL读取的图片不能输出，用np.array()转化会变成单通道的灰度图</p><p>三通道RGBnumpy读取显示是0-1，而不是0-255，这个是归一化的RGB！！正好和概率二分类对应！</p><p><strong>Snipaste竟然可以实时获取颜色值！！！如下：</strong></p><p><img src="/numpy-he-pandas-xue-xi/image-20201207093513840.png" alt="采集颜色值"></p>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> numpy </tag>
            
            <tag> pandas </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dp专题</title>
      <link href="dp-zhuan-ti/"/>
      <url>dp-zhuan-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="九章教程dp"><a href="#九章教程dp" class="headerlink" title="九章教程dp"></a>九章教程dp</h2><p><a href="https://www.bilibili.com/video/BV1xb411e7ww">https://www.bilibili.com/video/BV1xb411e7ww</a></p><p>可以解决三种类型的问题：1计数 2最值 3存在性</p><p>解动态规划需要开一个数组，一维、二维、三维，它代表什么</p><p>两个意识：<strong>最后一步</strong>  <strong>子问题</strong></p><p><img src="/dp-zhuan-ti/image-20201118000510306.png" alt="状态"></p><p><img src="/dp-zhuan-ti/image-20201118000813791.png" alt="转移"></p><h3 id="与递归的区别？"><a href="#与递归的区别？" class="headerlink" title="与递归的区别？"></a>与递归的区别？</h3>]]></content>
      
      
      <categories>
          
          <category> oj </category>
          
      </categories>
      
      
        <tags>
            
            <tag> dp </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>托福笔记</title>
      <link href="tuo-fu-bi-ji/"/>
      <url>tuo-fu-bi-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="曲根词汇"><a href="#曲根词汇" class="headerlink" title="曲根词汇"></a>曲根词汇</h2><h4 id="阅读记忆"><a href="#阅读记忆" class="headerlink" title="阅读记忆"></a>阅读记忆</h4><p>经济学人 时代 卫报</p><p>生词圈出，反复研读句子。勾画词组，了解替换，熟词辟意。</p><h4 id="词根词缀"><a href="#词根词缀" class="headerlink" title="词根词缀"></a>词根词缀</h4><p>prefix </p><ol><li>肯定，否定</li><li>方向</li><li>数字</li></ol><p>suffix</p><ol><li>词性</li></ol><p>root-根的逆推/想到熟词</p><ol><li>意义</li></ol><h4 id="词源-Etymology"><a href="#词源-Etymology" class="headerlink" title="词源 Etymology"></a>词源 Etymology</h4><p><strong>看读音，看拼写，看意思</strong></p><p>元音和元音字母组合之间可以替换：<strong>a,e,i,o,u,y</strong></p><p>辅音之间：<strong>p\b,t\d,k\g\c\qu\x,f\v,s\x\z\th</strong></p><p>形近字母的互换：<strong>u/v/w(特征是去掉元音),m/n（m/n可以省略）</strong></p><p>字母<strong>g、h</strong>的脱落（不发音）</p><p>造新词往往在<strong>单词结尾加轻辅音</strong></p><p>固定转换：s/t/d， p/b/ph/f/v        amorphous：form的倒写 </p><h4 id="字母组合（单音节，无词根词缀，-大体意思）"><a href="#字母组合（单音节，无词根词缀，-大体意思）" class="headerlink" title="字母组合（单音节，无词根词缀， 大体意思）"></a>字母组合（单音节，无词根词缀， 大体意思）</h4><p>sp表示发出，散开，产生</p><p>scr、cr多和手上的动作有关（注意：s在造词的时候无意义，只起到加强语气的作用）</p><p>词根词源字典：<a href="http://www.etymon.cn/index.html">http://www.etymon.cn/index.html</a></p><h4 id="联想法记单词"><a href="#联想法记单词" class="headerlink" title="联想法记单词"></a>联想法记单词</h4><p>单音节词汇 —-形近词  终点记不一样的地方</p><p>多音节词汇 —拆词，拆成认识的  词根词缀   拼音   熟词  与熟词形近的部分 等</p><p>​    </p><p>im/in: 1 into 2 not</p><p>vis: to see</p><p>it: to go</p><p>fact: to make</p><p>dis:1 not 2 apart</p><p>re:1 again 2 back</p><p>aneous:整体的形容词后缀</p><p>ade:名词后缀</p><p>er：n或v后缀，…的人</p><p>le:如果是动词，那么le就是动词后缀，往往表示动作的反复行为</p><p>ate:动词后缀</p><p>uous/ious/ous：形容词后缀</p><p>ish：形容词后缀，像$\cdots$一样的</p><p><strong>词根arch,archy= government,to rule统治</strong></p><p> ——词根arch 来自希腊语的arkhos，一般构成名词，亦可以当词根讲 意为government,to rule。arch 还有chief,first,old的含义。它们属于一对同源异形根，在派生词中，arch 常指统治的人物，作 ruler 统治者讲；而 archy 常指统治这一行为、方式，作rule 管理/管辖/统治或 government 政体讲。同义词根有来自希腊语的cracy/crat 和来自拉丁语的reg。</p><p>acc/app/ass/att，a+辅音双写表动作的加强</p><p>an/a：not</p><p><strong>后缀-ence,-ency的含义、词源和例词</strong></p><p>汉：来源于拉丁语及法语的名词后缀-ence(-ency)的用法与<a href="http://www.etymon.cn/yingyucizhui/yingyuhouzhui/205.html">-ance</a>(-ancy)基本相同。它们加在动词或动词词根后，意为the act or fact of ～ing或者the quality or condition of ～ing,即表示行为或该行为的性质状态等。这些名词往往有与之对应的以-ent结尾的形容词。</p><p> -ence,-ency与形容词后缀-ent相对应（如 difference-different；urgency-urgent），表示性质、状态、行为，后缀-ence和-ency义同，有些英语单词具有-ence和-ency两种形式（如 innocence = innocency ; persistency = persistence）</p><p>bene：词根 good male：词根evil</p><p>dict: to say</p><p>sion/dion: 名词后缀</p><p>vol:will 意愿</p>]]></content>
      
      
      <categories>
          
          <category> 英语 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tofel </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色恒常性之Bayesiancolorconstancy</title>
      <link href="yan-se-heng-chang-xing-zhi-bayesiandecisiontheory/"/>
      <url>yan-se-heng-chang-xing-zhi-bayesiandecisiontheory/</url>
      
        <content type="html"><![CDATA[<h2 id="论文思路"><a href="#论文思路" class="headerlink" title="论文思路"></a>论文思路</h2><p>论文：&lt;&lt;Bayesian color constancy &gt;&gt;</p><h3 id="Title-amp-amp-Abstract"><a href="#Title-amp-amp-Abstract" class="headerlink" title="Title&amp;&amp;Abstract"></a>Title&amp;&amp;Abstract</h3><p>MSE:</p><p><a href="https://blog.csdn.net/qq_36512295/article/details/86526799">https://blog.csdn.net/qq_36512295/article/details/86526799</a></p><p>MMSE:</p><p><a href="https://blog.csdn.net/tanghonghanhaoli/article/details/82751690?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160395601819724842903308%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160395601819724842903308&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-28-82751690.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=MMSE&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/tanghonghanhaoli/article/details/82751690?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160395601819724842903308%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160395601819724842903308&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v28-28-82751690.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=MMSE&amp;spm=1018.2118.3001.4187</a></p><blockquote><p>the Maximum Local Mass Estimate</p></blockquote><p><strong>什么是局部最大质量估计？</strong></p><h3 id="Figure"><a href="#Figure" class="headerlink" title="Figure"></a>Figure</h3><p><strong>Figure1</strong></p><blockquote><p>We assume that each surface is <strong>flat and matte</strong>, so that it may be characterized by a single spectral reflectance function</p></blockquote><p><strong>为什么要flat and matte?</strong></p><p>平坦是保证处处一致，无光泽不光滑是保证是漫反射吧应该？</p><blockquote><p>The spectral power distri- bution of the light reaching the observer from each surface is given as the <strong>wavelength-by-wavelength product</strong> of the illuminant spectral power distribution and the surface reflectance function.</p></blockquote><p><strong>什么是wavelength-by-wavelength product?</strong></p><p>二者直接相乘</p><p><strong>Figure2</strong></p><p>Fig2（a）:</p><p>对于简单的乘积例子，给定高斯噪声时，后验分布的图像，最优解在岭处</p><p>Fig2（b）：</p><p>横截面表明，即使在岭处都有最大的固定值，一些局部区域也会含有不同的概率质量</p><hr><p><strong>什么是parametre vector？参数是什么意思？</strong></p><p>Y=ax+b Y是因变量，x是自变量，a,b就是参数</p><p><strong>什么是rendering equation？</strong></p><p><a href="https://zhuanlan.zhihu.com/p/52497510">https://zhuanlan.zhihu.com/p/52497510</a></p><p><strong>什么是Gaussian observation noise？高斯噪声？</strong></p><p>高斯噪声百度百科：<a href="https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0/8587563?fr=aladdin">https://baike.baidu.com/item/%E9%AB%98%E6%96%AF%E5%99%AA%E5%A3%B0/8587563?fr=aladdin</a></p><p>为什么深度学习去噪都采用高斯白噪声？<a href="https://www.zhihu.com/question/67938028">https://www.zhihu.com/question/67938028</a></p><p>高斯白噪声解释：<a href="https://blog.csdn.net/szlcw1/article/details/41758711">https://blog.csdn.net/szlcw1/article/details/41758711</a></p><p><strong>Figure3</strong></p><hr><p><strong>delta loss function损失函数？</strong></p><p>常见损失函数：<a href="https://blog.csdn.net/perfect1t/article/details/88199179">https://blog.csdn.net/perfect1t/article/details/88199179</a></p><p>应该就是指单峰函数，0-1函数$\delta(\widetilde{x}-x)=0\quad if(\widetilde{x}=x)$ 相同的是预判正确的，所以是没有损失的</p><p><strong>期望损失？</strong></p><p><a href="https://blog.csdn.net/hx14301009/article/details/79870851">https://blog.csdn.net/hx14301009/article/details/79870851</a></p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><h4 id="A-Why-Color-Constancy-is-Difficult"><a href="#A-Why-Color-Constancy-is-Difficult" class="headerlink" title="A. Why Color Constancy is Difficult"></a>A. Why Color Constancy is Difficult</h4><p>1.Problem Statement</p><blockquote><p>The entries of sj specify the fraction of incident light reflected in Nl evenly spaced wavelength bands throughout the visible spectrum</p></blockquote><p><strong>是不是错了，应该是reflected in</strong> $N_j$<strong>?这句话怎么理解?</strong></p><p>应该意思是$N_l$个均匀排列波长带</p><p>2.Why It Is Difficult</p><blockquote><p>It is underdetermined and it is nonlinear.</p></blockquote><p><strong>什么是欠定的？</strong></p><p><a href="http://blog.sina.com.cn/s/blog_531bb7630100xx6c.html">http://blog.sina.com.cn/s/blog_531bb7630100xx6c.html</a></p><blockquote><p>If we have data from N image locations (say, 10) and assume one illuminant, then we have NNr measurements (e.g., 10 x 3 = 30) available to estimate Nl(N + 1) scene parameters [e.g., 31 x (10 + 1) = 341].</p></blockquote><p><strong>这句话怎么理解？</strong></p><blockquote><p>To address the underdeterminancy of color constancy, previous investigators have described spectral functions by using low-dimensional linear models</p></blockquote><p>什么是低维线性模型？</p><p><a href="https://mp.weixin.qq.com/s?src=11&amp;timestamp=1604305021&amp;ver=2681&amp;signature=FecbuKdwyqukrDBQO*pJ3q2jZFxLcCWxabeUx7eeSsOp9MNNUxijWNnlaNGRWguX2sl69suc3xXZInrRwvy-CsE1AVD*Vr3NvyjihI-8QmMzO04JeBJpKBXi75iy89*z&amp;new=1">https://mp.weixin.qq.com/s?src=11&amp;timestamp=1604305021&amp;ver=2681&amp;signature=FecbuKdwyqukrDBQO<em>pJ3q2jZFxLcCWxabeUx7eeSsOp9MNNUxijWNnlaNGRWguX2sl69suc3xXZInrRwvy-CsE1AVD</em>Vr3NvyjihI-8QmMzO04JeBJpKBXi75iy89*z&amp;new=1</a></p><blockquote><p>The columns of $B_e$ are the basis functions of the linear model, since the matrix product $B_ew_e$ expresses a weighted sum of these columns.</p></blockquote><p><strong>什么是基函数？</strong></p><p><a href="https://www.jianshu.com/p/5cc427f0df33">https://www.jianshu.com/p/5cc427f0df33</a></p><blockquote><p>If we assume that a population of spectra lie within an $N_m$-dimensional linear model, then we can parameterize the spectra by specifying the model weights.</p></blockquote><p><strong>这句话如何理解？</strong></p>]]></content>
      
      
      <categories>
          
          <category> Color Constancy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CC/AWB </tag>
            
            <tag> Bayes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组会总结</title>
      <link href="zu-hui-zong-jie/"/>
      <url>zu-hui-zong-jie/</url>
      
        <content type="html"><![CDATA[<h2 id="10-20"><a href="#10-20" class="headerlink" title="10.20"></a>10.20</h2><ol><li>ACCV 大概在六七月份</li><li>为什么定这几级，理论依据是什么？现有的分级标准，为什么这么分？理论依据？出于什么考量？</li><li>写论文博客时，要分两个过程，自己读主要写每个细节，按照论文的流程走下来；和别人讲、真正理解是要按自己的思路把整个流程理一遍</li><li><img src="/zu-hui-zong-jie/image-20201021103706939.png" alt="IJCAI"></li><li><img src="/zu-hui-zong-jie/image-20201021103921695.png" alt="ICCV"></li></ol><h2 id="10-30"><a href="#10-30" class="headerlink" title="10.30"></a>10.30</h2><ol><li>DCT、GAN、自监督</li><li>学习宇翔学长如何讲</li><li>时间和效率都要保证 太堕落了</li><li>下次组会前要把三篇贝叶斯看完加代码整完</li></ol><h2 id="11-19"><a href="#11-19" class="headerlink" title="11.19"></a>11.19</h2><ol><li>还是要做ppt，相当于再捋一次思路，锻炼提炼总结能力。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 奇奇怪怪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇怪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>conda使用</title>
      <link href="conda-shi-yong/"/>
      <url>conda-shi-yong/</url>
      
        <content type="html"><![CDATA[<p>pip安装包应该是安装到了Lib/site-packages</p><p>菜鸟教程pip使用介绍：<a href="https://www.runoob.com/w3cnote/python-pip-install-usage.html">https://www.runoob.com/w3cnote/python-pip-install-usage.html</a></p><p>windows用命令行运行python文件</p><p>利用anaconda prompt ，然后 python  *.py</p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> conda </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>奇奇怪怪不成体系问题合集</title>
      <link href="qi-qi-guai-guai-bu-cheng-ti-xi-wen-ti-he-ji/"/>
      <url>qi-qi-guai-guai-bu-cheng-ti-xi-wen-ti-he-ji/</url>
      
        <content type="html"><![CDATA[<h2 id="HP打印机状态需要注意、打印显示用户干预如何处理？"><a href="#HP打印机状态需要注意、打印显示用户干预如何处理？" class="headerlink" title="HP打印机状态需要注意、打印显示用户干预如何处理？"></a>HP打印机状态需要注意、打印显示用户干预如何处理？</h2><p>和打印机连接在<strong>同一Wifi并已经添加了打印机</strong>的情况下，<strong>右键打印机</strong>-&gt;<strong>属性</strong>-&gt;<strong>Web服务</strong>，获得<strong>打印机IP</strong>，然后<strong>右键打印机</strong>-&gt;<strong>打印机属性</strong>-&gt;<strong>端口</strong>-&gt;<strong>添加端口</strong>-&gt;<strong>Standard TCP/IP Port</strong>-&gt;<strong>输入你的打印机的IP</strong>-&gt;<strong>填写随便一个端口名</strong>-&gt;<strong>应用</strong>-&gt;<strong>问题解决</strong>！</p><h2 id="文件扩展名？什么是-mat文件？"><a href="#文件扩展名？什么是-mat文件？" class="headerlink" title="文件扩展名？什么是.mat文件？"></a>文件扩展名？什么是.mat文件？</h2><p>文件扩展名查询：<a href="https://www.reviversoft.com/zh-cn/file-extensions/mat">https://www.reviversoft.com/zh-cn/file-extensions/mat</a></p><h2 id="Chrome实时字幕打开？"><a href="#Chrome实时字幕打开？" class="headerlink" title="Chrome实时字幕打开？"></a>Chrome实时字幕打开？</h2><p>首先，将Chrome更新到Canary 84.0.4136.1或更高版本，接着在地址栏中输入“Chrome://flags”，进入到Chrome的实验功能界面。</p><p>搜索“Live Captions”，将这个实时字幕的选项打开。</p><p>重启Chrome，进入到设置界面。在“高级”中找到“无障碍”，就可以看到实时字幕功能了，开启即可。</p>]]></content>
      
      
      <categories>
          
          <category> 奇奇怪怪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 奇怪 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>肤色分级与系统</title>
      <link href="fu-se-fen-ji-yu-xi-tong/"/>
      <url>fu-se-fen-ji-yu-xi-tong/</url>
      
        <content type="html"><![CDATA[<h2 id="论文阅读-lt-lt-Brief-overview-of-PANTONE-SkinTone-Guide-chart-in-CIEL-a-b-color-space-gt-gt"><a href="#论文阅读-lt-lt-Brief-overview-of-PANTONE-SkinTone-Guide-chart-in-CIEL-a-b-color-space-gt-gt" class="headerlink" title="论文阅读-<<Brief overview of PANTONE SkinTone Guide chart in CIEL*a*b* color space>>"></a>论文阅读-&lt;&lt;Brief overview of PANTONE SkinTone Guide chart in CIEL*a*b* color space&gt;&gt;</h2><h3 id="Title-amp-Keywords-amp-Abstract-amp-Conclusion"><a href="#Title-amp-Keywords-amp-Abstract-amp-Conclusion" class="headerlink" title="Title&amp;Keywords&amp;Abstract&amp;Conclusion"></a>Title&amp;Keywords&amp;Abstract&amp;Conclusion</h3><h4 id="CIEL-a-b-color-space"><a href="#CIEL-a-b-color-space" class="headerlink" title="CIEL*a*b* color space?"></a>CIEL*a*b* color space?</h4><p><strong>颜色开发培训讲义</strong>：<a href="https://www.zhihu.com/column/cxqingzong-color">https://www.zhihu.com/column/cxqingzong-color</a>     <strong>这篇不能更赞</strong></p><p><strong>可见光谱:</strong></p><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201014213348777.png" alt="可见光谱"></p><p>我们所说的<strong>颜色主要分两种</strong>：</p><blockquote><p><strong>光源色（light source color）</strong>：来自发光体的颜色。如太阳，灯泡，led灯，等等。</p><p><strong>表面色（surface color</strong>）：不是来自发光体的物体色。物体本身不发光，但能看到物体的颜色，是因为这些物体能对来自于其他发光体的光的选择性的吸收和反射。</p></blockquote><p>颜色也可以简单分为两大类：</p><blockquote><p><strong>非彩色</strong>：黑白灰</p><p><strong>彩色</strong>：红黄蓝绿等</p></blockquote><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201014210822647.png" alt="彩色与非彩色"></p><p><strong>颜色感知的三要素，光源，物体和观察者，缺一不可，缺少一个要素，我们看不到颜色，或者其中一个要素发生改变，我们看到的颜色都会不一样。</strong></p><p><strong>1光源</strong></p><p><strong>不同光源性质是不一样的</strong>，有些光源会亮一点白一点，如太阳，或者就是太阳光，一天内不同时间段的太阳光也会有很大差异，导致在这些不同的光源下看相同一个颜色都会有很大差异.</p><p>所以我们在<strong>颜色开发或者颜色沟通交流的时候，会指定一个标准光源</strong>，这样能确保我们双方看颜色条件的一致性。我们比对颜色使用的光源都是有标准规定的光源。通常在下图所示的对色灯箱里看颜色。灯箱里面装有不同的常用光源。</p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201014215437189.png" alt="对色灯塔及常见光源" style="zoom: 67%;"><blockquote><p><strong>Light sources：发光体（照明体）</strong>。泛指能发出光（可见光）的物体，如太阳，蜡烛，灯泡等。但是有些发光体发出的光是变化的不稳定的。例如太阳光，就算在同一天光照辐射都是不一样的，是变化的，更何况在不同的天气，不同的季节。所以很难用这些不稳定的光源来进行对颜色的描述和交流。</p><p><strong>lluminants：光源</strong>。是一个可以定量描述的发光体。是国际照明委员会 CIE（Commission Internationale de L’Eclairage）为了对颜色的评估和计算而定义了不同类型的，能用数学表（相对能量和波长)表示的标准光源。</p></blockquote><p><strong>色温Color temperature是照明光学中用于定义光源颜色的一个物理量。光源的色温是以光源发光时所显现的颜色与一个绝对黑体被高温燃烧时所显现的颜色相一致时的燃烧温度来定义的，它的单位是绝对温度Kelvin开尔文【K】。是为了量化光源色彩的一个物理量</strong></p><p>开尔文与摄氏度的转换关系如下：</p><p><strong>K(开尔文）=273.15+T(摄氏度）</strong></p><p>K值越高，显现的颜色就愈趋向于白蓝色；K值越低，显现的颜色就愈趋向于黄红色。</p><p>开尔文认为，假定纯黑体，能够将落在其上的所有热量吸收，而没有损失，同时又能够将热量生成的能量全部以“光”的形式释放出来的话，它产生辐射最大强度的波长随温度变化而变化。</p><p><strong>显色指数color rendering index (CRI)</strong> :<strong>与标准的参考光源相比较，一个光源对物体颜色外貌所产生的效果</strong>。换句话说，是<strong>一个光源与标准光源（例如日光）相比较下在颜色辨认方面的一种测量方式</strong>。CRI是一种得到普遍认可的度量标准，也是目前评价与报告<strong>光源显色性</strong>的惟一途径。</p><p><strong>Ra</strong> <strong>=</strong> <strong>物体在某一光源照射下所显现的颜色 ÷ 物体本身所具有的颜色</strong>。</p><p>Ra表示某光源的显色指数。Ra愈接近100%，<strong>表明在该光源照射下，物体所显现的颜色与物体本身所具有的颜色的差异就愈小</strong>。</p><p><strong>标准光源</strong>的光谱要求如下：</p><p>（1）光源的<strong>色温必须是5000K-6500K</strong>，在这种光源色温下观察颜色的效果基本类似于中国大部分地区上午8点至10点，下午3点至5点的自然光下的观察效果。</p><p>（2）光源的<strong>显色指数Ra&gt;90</strong></p><p>光源的性质，可以通过<strong>光谱功率分布曲线（SPD）</strong>来描述。不同的光源有着不同的光谱功率分布曲线。光谱功率分布（SPD）的意思就是光源发出可见光的不同光谱波长（400nm~700nm）的功率是不同的。功率可以理解成强度的大小。</p><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201015094547985.png" alt="常用光源的光谱功率分布曲线"></p><p><strong>2物体</strong></p><blockquote><p><strong>物体关于颜色的性质是对不同波长的电磁波的选择性吸收</strong>，所以我们用<strong>光谱反射率曲线</strong>来表达物体的这种性质。<strong>红色绿色蓝色</strong>的光谱反射率曲线的<strong>最大特征</strong>是，它<strong>有明显的波峰</strong>。<strong>波峰所在的位置的电磁波波长代表着这个物体的颜色</strong>。</p><p>但是<strong>黑白灰</strong>就不一样。物体之所以能够呈现出<strong>白色</strong>，是因为这个物体对<strong>不同波长的电磁波几乎都不吸收</strong>，所以都被反射出来。<strong>黑色</strong>跟白色刚好相反，黑色物体<strong>几乎完全吸收所有波长的电磁波</strong>，所以从黑色的光谱反射率曲线来看，所有波长的光谱的反射率都很低很低。</p></blockquote><p><strong>3观察者人眼：</strong></p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201015095247048.png" alt="人眼观察黄光" style="zoom:67%;"><p>类似人眼三种视锥细胞对不同波长的光的响应，研究人员也得到一个标准观察者的三刺激值（x，y，z），作为测色仪辨别颜色的视锥细胞。通过这三个参数xyz，来描述一个颜色，也就是后面将要介绍的<strong>CIE-XYZ颜色空间</strong>。</p><p><strong>CIE-XYZ颜色空间：</strong></p><p>我们将<strong>光源</strong>、<strong>物体</strong>和<strong>观察者</strong>这三要素的性质相乘，也就是光源的光谱功率分布曲线乘以物体的光谱反射率曲线乘以标准观察者，得到三个参数<strong>X，Y，Z</strong>（都是大写字母），不同的颜色，有着不同XYZ值。</p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201015100147722.png" alt="CIEXYZ" style="zoom:80%;"><p>按照下图里的公式算出<strong>x</strong>（小写X），<strong>y</strong>（小写Y）。<strong>xyz值（小写）代表着XYZ（大写）的占比</strong>，这样三个参数缩减到两个参数，<strong>两个参数形成一个平面的二维颜色空间，也就是CIE-XYZ颜色空间</strong>。CIE XYZ颜色空间具有不均匀性。</p><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201015100255681.png" alt="CIE-XYZ颜色空间"></p><p><strong>缺点：不容易对颜色差异的大小进行判定</strong>，<strong>无法非常直观的判定这个颜色</strong>就是我需要的颜色，不知道这个颜色跟我需要的颜色的差异的大小。</p><p>我们把<strong>人眼感觉不出的色彩差别量（变化范围）叫做颜色的宽容量</strong>。颜色的宽容量反映在<strong>CIExy色度图上即为两个色度点之间的距离</strong>。因为，每种颜色在色度图上是一个点，但<strong>对人的视感觉来说，当这种颜色的色度坐标位置变化很小时，人眼仍认为它是原来的颜色，感觉不出它的变化。</strong>所以，对视感觉效果来说，<strong>在这个变化的距离（或范围）以内的色彩差别量，在视觉效果上是等效的。</strong>对色彩复制和其它颜色工业部门来说这种位于人眼宽容量范围之内的色彩差别量是允许存在的。</p><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201015220402922.png" alt="不同标准色度点的颜色宽容量"></p><p><strong>CIE-L*a*b*颜色空间：</strong></p><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201016174528078.png" alt="介绍"></p><p>跟之前介绍的孟塞尔颜色体系的颜色空间是一样，是三维空间中立体的球形。空间中有三个维度，形成三个互相垂直的轴，分别是：</p><ul><li>L*轴：从上到下；<strong>表示明度</strong>，范围由0到100，表示颜色从深（黑）到浅（白）。</li><li>a*轴：从左到右；<strong>表示红绿</strong>，数值变化由正到负，表示颜色从红（正）到绿（负）。a值越大颜色越红，a值越小颜色越绿。</li><li>b*轴：从里到外。<strong>表示黄蓝</strong>，数值变化由正到负，表示颜色从黄（正）到蓝（负）。b值越大颜色越黄，b值越小颜色越蓝。</li><li><img src="/fu-se-fen-ji-yu-xi-tong/image-20201015100941807.png" alt="CIE-L*a*b*"></li></ul><p><strong>两个颜色之间的差异大小</strong>。引入一个概念——<strong>色差△E</strong>。<strong>两个颜色的差异大小，就是这两个颜色的在颜色空间上两个点的距离</strong>。色差的计算公式如下：</p><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201015100802146.png" alt="色差的计算公式"></p><p><strong>同色异谱：</strong></p><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019221820491.png" alt="同色异谱"></p><blockquote><p>有时候我们看两个物体的颜色，在某种场景下，比如上图左边的两个物体在室外太阳光底线看起来颜色的一样的，但是一旦我们拿到室内，如上图右边，在荧光灯管底线发现，其实这两个物体的颜色是相差非常大的。这就是同色异谱现象，<strong>同色异谱也叫做条件对色</strong>，顾名思义，这两个颜色只有符合一定观察条件下颜色才能相等，实际上这两个颜色并非完全一样。</p></blockquote><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019222411178.png" alt="同色异谱"></p><blockquote><p><strong>同色异谱（条件等色）的根源在于两物体的光谱反射率曲线不同</strong>，也就是说有不同的颜色色粉配方。同色异谱中的<strong>“谱”指的就是光谱反射率曲线</strong>。如下图，就是上面两个颜色色卡的光谱反射率曲线，可以看到两者的差异是非常大的。也可以看到两个光谱反射率曲线的交叉点很多。</p><p>《颜色技术原理》中提到过史泰鲁斯 （stiles）和 维 泽 斯 基（ wyszecki）发现两个同色异谱的颜色的光谱反射曲线在可见光谱波段 （400~700nm） 内， 至少在三个不同波长上必须具有相同的反射率。也就是两者的光谱反射率曲线至少要有三个交叉点 。</p></blockquote><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019222914891.png" alt="不同的光谱反射率曲线"></p><p>常见颜色空间介绍：<a href="https://blog.csdn.net/JiangHui1211/article/details/84592774?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param">https://blog.csdn.net/JiangHui1211/article/details/84592774?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param</a></p><p><strong>RGB颜色空间</strong>:</p><p><strong>任意色光F</strong>都可以用RGB<strong>三种颜色不同分量的相加混合而成</strong>：**F=r[R]+g[G]+b[B]**。</p><p><strong>一般我们读取图片获得的三维矩阵是RGB空间</strong></p><p><strong>色度学规则</strong>：<br>　　(1)通过<strong>R,G,B这三种颜色能产生任何颜色</strong>，并且<strong>这三种颜色混合后产生的颜色是唯一</strong>的。<br>　　(2)如果<strong>两个颜色相等，这三个颜色分量再乘以或者除以相同的数，得到的颜色仍然相等</strong>。<br>　　(3)<strong>混合色的亮度等于每种颜色亮度的和</strong>。</p><p><strong>RGB颜色空间</strong>的<strong>均匀性非常差，且两种颜色之间的知觉差异色差不能表示为该颜色空间中两点间的距离</strong>，但是<strong>利用线性或非线性变换</strong>，则<strong>可以从RGB颜色空间推导出其他的颜色特征空间</strong>。</p><p><strong>CMYK模式：</strong></p><p>俗称<strong>四色打印模式</strong>，是最佳的打印模式。因为在实际应用中，青色、洋红色和黄色很难叠加形成真正的黑色，最多不过是褐色而已。因此才引入了K——黑色。黑色的作用是强化暗调，加深暗部色彩。</p><p><strong>HSV颜色空间：</strong></p><p>感觉和孟塞尔颜色体系很像。**HSV即色相(Hue)、饱和度(Saturation)、明度(Value)，又称HSB(B即Brightness)**。</p><p>RGB和CMYK<strong>面向硬件</strong>，可用于<strong>图片编码</strong>；HSV<strong>面向用户</strong>，可用于<strong>图片编辑软件</strong>。</p><p><strong>sRGB色彩空间：</strong></p><p>standard Red Green Blue，<strong>标准红绿蓝色彩空间</strong>是惠普与微软于1996年一起开发的用于<strong>显示器、打印机以及因特网的一种标准RGB</strong>色彩空间。这种标准得到了W3C、Exif、英特尔、Pantone、Corel以及其它许多业界厂商的支持。</p><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201015222536629.png" alt="sRGB色域"></p><p>维基百科：<a href="https://zh.wikipedia.org/wiki/Lab%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4">https://zh.wikipedia.org/wiki/Lab%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%97%B4</a></p><p>在<strong>RGB</strong>或<strong>CMYK</strong>值与<strong>L*a*b*</strong> 之间没有转换的简单公式，因为<strong>RGB和CMYK色彩空间是设备依赖的</strong>。RGB或CMYK值<strong>首先必须被变换到特定绝对色彩空间中，比如sRGB或Adobe RGB</strong>。这种调整将是设备依赖的，但是<strong>变换的结果数据是设备无关的</strong>，允许把数据变换成<strong>CIE 1931色彩空间</strong>并接着变换成<strong>L*a*b*</strong>。</p><h4 id="Hue-Angle色相角"><a href="#Hue-Angle色相角" class="headerlink" title="Hue Angle色相角?"></a>Hue Angle色相角?</h4><blockquote><p>孟塞尔颜色体系：</p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201014214736980.png" alt="image-20201014214736980" style="zoom:50%;"><p><strong>1）色相/色调/Hue</strong>，对于色相我们比较熟悉的是这个色环，色环上不同位置代表不同色相。色相的排列顺序是按照可见光波长从低到高，逆时针分布。这是色相环的概念。把一周均分成五5种主色互相调和成五种中间色，相邻的两个位置之间再均分10份，共100份</p><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201015221249004.png" alt="色相带"></p><p><strong>2）明度/Value/Lightness</strong>，很容易理解，就是一个颜色中含有白和黑的比例：白越多黑越少，这个颜色的明度就越高。</p><p><strong>3）色度chroma</strong>。是一个颜色里面含有这个色相的浓度。<strong>很多人容易把饱和度和明度的概念混淆。是因为他们不理解饱和度和明度在色彩空间中的位置。明度在色彩空间中的位置是从顶部到底部，明度从高到低。而饱和度在色彩空间中的位置是从里到外，饱和度从低到高。</strong></p></blockquote><h4 id="色度-色域？"><a href="#色度-色域？" class="headerlink" title="色度?色域？"></a>色度?色域？</h4><p>研究颜色测量的学科叫做<strong>色度学</strong>，色度学的任务就是用数量化来表征色觉特性。色度”中的“度”是度量的意思。 类似于长度，高度等等概念。度量长度或高度使用的工具是尺子，而度量颜色的工具就是<strong>颜色感知三要素</strong>。</p><p><strong>色域</strong>是对一种颜色进行编码的方法，也指一个技术系统能够产生的颜色的总合。在计算机图形处理中，色域是<strong>颜色的某个完全的子集</strong>。颜色子集最常见的应用是用来精确地代表一种给定的情况。例如一个给定的色彩空间或是某个输出装置的呈色范围。</p><h3 id="Figure"><a href="#Figure" class="headerlink" title="Figure"></a>Figure</h3><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019170452039.png" alt="Table1" style="zoom:50%;"><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019170512027.png" alt="Table2" style="zoom:50%;"><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019170533519.png" alt="Figure1" style="zoom:50%;"><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019170555412.png" alt="Figure2" style="zoom:50%;"><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019170613588.png" alt="Figure3" style="zoom:50%;"><blockquote><p>lightness and chroma:亮度和色度</p><p>yellow and red categories:Hue色相</p></blockquote><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019215839363.png" alt="观察者"></p><blockquote><p>用于色彩排列和分类的这种三维系统已经融入目前广泛使用的<strong>色彩空间模型、色差公式和色容差系统</strong>。</p></blockquote><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019223925779.png" alt="转换" style="zoom:67%;"><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019224245507.png" alt="从色彩到色彩测量" style="zoom:50%;"><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019224402876.png" alt="从色彩到色彩测量" style="zoom:50%;"><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><blockquote><p><strong>Applications</strong>:</p><ol><li>diagnosis and treatments of cutaneous disorders </li><li>matching our body color to get maxillofacial soft tissue prostheses</li><li>face detection and recognition</li><li>cosmetics</li></ol><p>CIEL*a*b* is a <strong>device-independent color space</strong> which we used in our study.</p></blockquote><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><blockquote><p>110 colors numbered from 1Y01 SP to 4R15 SP</p><p> the first number <strong>indicates the chroma, varies from 1 to 5</strong> which it is the highest</p><p> the rigid represents <strong>yellowness (Y)</strong> or <strong>redness (R) as hue</strong> and </p><p><strong>two last numbers show the lightness, varies from 1 to 15</strong> which it is the darkest. These samples are sorted in <strong>decreasing order</strong> of lightness (5).</p></blockquote><h2 id="小实验"><a href="#小实验" class="headerlink" title="小实验"></a>小实验</h2><blockquote><p>MATLAB Api：<a href="https://www.mathworks.com/help/">https://www.mathworks.com/help/</a></p></blockquote><pre class=" language-matlab"><code class="language-matlab"><span class="token comment" spellcheck="true">% shows example of illuminant estimation based on Grey-World, Shades of</span><span class="token comment" spellcheck="true">% Gray, max-RGB, and Grey-Edge algorithm</span><span class="token comment" spellcheck="true">%example images</span>input_im<span class="token operator">=</span><span class="token function">double</span><span class="token punctuation">(</span><span class="token function">imread</span><span class="token punctuation">(</span><span class="token string">'test_3.jpg'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token function">uint8</span><span class="token punctuation">(</span>input_im<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">'input image'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% %Grey-World</span><span class="token comment" spellcheck="true">% [wR,wG,wB,out]=general_cc(input_im,0,1,0);</span><span class="token comment" spellcheck="true">% figure(2);</span><span class="token comment" spellcheck="true">% imshow(uint8(out));</span><span class="token comment" spellcheck="true">% title(</span><span class="token string">'Grey-World'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%max-RGB</span><span class="token comment" spellcheck="true">% [wR,wG,wB,out]=general_cc(input_im,0,-1,0);</span><span class="token comment" spellcheck="true">% figure(3);imshow(uint8(out));</span><span class="token comment" spellcheck="true">% title(</span><span class="token string">'max-RGB'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% Shades of Grey</span>mink_norm<span class="token operator">=</span><span class="token number">5</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">% any number between 1 and infinity</span><span class="token punctuation">[</span>wR<span class="token punctuation">,</span>wG<span class="token punctuation">,</span>wB<span class="token punctuation">,</span>out<span class="token punctuation">]</span><span class="token operator">=</span><span class="token function">general_cc</span><span class="token punctuation">(</span>input_im<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>mink_norm<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token function">uint8</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">title</span><span class="token punctuation">(</span><span class="token string">'Shades of Grey'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% Grey-Edge</span><span class="token comment" spellcheck="true">% mink_norm=5;    % any number between 1 and infinity</span><span class="token comment" spellcheck="true">% sigma=2;        % sigma </span><span class="token comment" spellcheck="true">% diff_order=1;   % differentiation order (1 or 2)</span><span class="token comment" spellcheck="true">% [wR,wG,wB,out]=general_cc(input_im,diff_order,mink_norm,sigma);</span><span class="token comment" spellcheck="true">% figure(5);imshow(uint8(out));</span><span class="token comment" spellcheck="true">% title(</span><span class="token string">'Grey-Edge'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% 截取皮肤区域</span><span class="token comment" spellcheck="true">% out=out(375:480,185:290,:);</span><span class="token comment" spellcheck="true">% out=out(360:420,360:420,:);</span>out<span class="token operator">=</span><span class="token function">out</span><span class="token punctuation">(</span><span class="token number">165</span><span class="token operator">:</span><span class="token number">240</span><span class="token punctuation">,</span><span class="token number">230</span><span class="token operator">:</span><span class="token number">320</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% 展示截取皮肤区域</span><span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">imshow</span><span class="token punctuation">(</span><span class="token function">uint8</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% convert to lab</span>labI <span class="token operator">=</span> <span class="token function">rgb2lab</span><span class="token punctuation">(</span><span class="token function">uint8</span><span class="token punctuation">(</span>out<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">%seperate l,a,b</span><span class="token comment" spellcheck="true">%matlab的下标从1开始</span>l <span class="token operator">=</span> <span class="token function">labI</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a <span class="token operator">=</span> <span class="token function">labI</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>b <span class="token operator">=</span> <span class="token function">labI</span><span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token operator">:</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">% % 显示各维度直方图</span><span class="token comment" spellcheck="true">% figure(4);</span><span class="token comment" spellcheck="true">% hist(l);</span><span class="token comment" spellcheck="true">% figure(5);</span><span class="token comment" spellcheck="true">% hist(a);</span><span class="token comment" spellcheck="true">% figure(6);</span><span class="token comment" spellcheck="true">% hist(b);</span><span class="token comment" spellcheck="true">%网格曲面图</span><span class="token function">figure</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">meshc</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">subplot</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">meshz</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>l<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><img src="/fu-se-fen-ji-yu-xi-tong/result_0.png" alt="result_0" style="zoom: 50%;"><img src="/fu-se-fen-ji-yu-xi-tong/result_1.png" alt="result_1" style="zoom: 50%;"><p><img src="/fu-se-fen-ji-yu-xi-tong/result_3.png" alt="result_3" style="zoom: 67%;"><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019214729213.png" alt="image-20201019214729213"></p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019214825960.png" alt="三维图" style="zoom:80%;"><h2 id="接下来打算要做"><a href="#接下来打算要做" class="headerlink" title="接下来打算要做"></a>接下来打算要做</h2><p><img src="/fu-se-fen-ji-yu-xi-tong/image-20201019155029016.png" alt="计划流程图"></p><h2 id="Pantone-Skintone-Review"><a href="#Pantone-Skintone-Review" class="headerlink" title="Pantone Skintone Review"></a>Pantone Skintone Review</h2><p>彩通肤色指南[PANTONE SkinTone Guide]是根据科学测量各种人类皮肤类型中数干种实际肤色而建立。这个色库为再现实体肤色而配制，是人类肤色的完整视觉参考，适用于与肤色相关的任何市场。</p><p>首个匹配和再现逼真肤色的科学指南，适用于各个行业。1000多种人体皮肤测量值，收集于不同年龄和种族的参与者。为获得一致的样品精确度．采用几种高端X—Rite分光光度计和小巧的手持PANTONE CAPSURE分光光度计来测量皮肤样本。根据这些测量值，Pantone<br>建立了精确的皮肤色彩空间．并创建了彩通肤色色库(PANTONE SkinToneLibrary)．它确定了1 10种再现性最强的色彩。<br><strong>现有的主要问题是，这110种肤色是如何确定的？</strong></p><p><strong>这也是我们需要做的！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 肤色分级 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 肤色分级 </tag>
            
            <tag> 颜色空间 </tag>
            
            <tag> MATLAB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>人脸识别与肤色分类</title>
      <link href="ren-lian-shi-bie-yu-fu-se-fen-lei-ji-dlib-ku/"/>
      <url>ren-lian-shi-bie-yu-fu-se-fen-lei-ji-dlib-ku/</url>
      
        <content type="html"><![CDATA[<h2 id="莫名其妙被另一个文件覆盖了？？？文件丢失？？为什么呀我吐了！"><a href="#莫名其妙被另一个文件覆盖了？？？文件丢失？？为什么呀我吐了！" class="headerlink" title="莫名其妙被另一个文件覆盖了？？？文件丢失？？为什么呀我吐了！"></a>莫名其妙被另一个文件覆盖了？？？文件丢失？？为什么呀我吐了！</h2><p>格式化输出，文字和数字等混合输出时使用！</p><pre class=" language-python"><code class="language-python"><span class="token string">"Skipping {}"</span><span class="token punctuation">.</span>format<span class="token punctuation">(</span>img_path<span class="token punctuation">)</span></code></pre><p>文件读取</p><p><a href="https://www.cnblogs.com/ymjyqsx/p/6554817.html">https://www.cnblogs.com/ymjyqsx/p/6554817.html</a></p><p>with open as f 为了保证无论是否出错都能正确地关闭文件</p><pre class=" language-python"><code class="language-python"><span class="token keyword">with</span> open<span class="token punctuation">(</span><span class="token string">"locs.txt"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span> <span class="token keyword">as</span> f<span class="token punctuation">:</span>    <span class="token comment" spellcheck="true">#f.write(fname+"\n")</span>    <span class="token keyword">for</span> line <span class="token keyword">in</span> f<span class="token punctuation">.</span>readlines<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span> <span class="token comment" spellcheck="true">#每个line都是str</span>        linelist<span class="token operator">=</span>line<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#字符串切割</span></code></pre><p>split():str.split(str=””, num=string.count(str))</p><p>str –分隔符，默认为所有的空字符，包括空格、换行(\n)、制表符(\t)等。</p><p>num – 分割次数。默认为 -1, 即分隔所有。</p><p>返回分割后的字符串列表。</p><p>进度条</p><pre class=" language-python"><code class="language-python"><span class="token keyword">from</span> tqdm <span class="token keyword">import</span> tqdm<span class="token keyword">for</span> fname <span class="token keyword">in</span> tqdm<span class="token punctuation">(</span>os<span class="token punctuation">.</span>listdir<span class="token punctuation">(</span>input_dir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span></code></pre><p>绝对路径和相对路径</p><p><a href="https://blog.csdn.net/databatman/article/details/49453953">https://blog.csdn.net/databatman/article/details/49453953</a></p><p>strip():</p><p><strong>strip()</strong> 处理的时候，如果不带参数，默认是清除两边的空白符，例如：<strong>\n</strong>, <strong>\r</strong>, <strong>\t</strong>, <strong>‘ ‘</strong>)。</p><pre class=" language-python"><code class="language-python">str <span class="token operator">=</span> <span class="token string">'123@163.com'</span><span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">'132'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#@163.com</span>str <span class="token operator">=</span> <span class="token string">'123@163.com'</span><span class="token keyword">print</span><span class="token punctuation">(</span>str<span class="token punctuation">.</span>strip<span class="token punctuation">(</span><span class="token string">'23'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">#123@163.com</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> face_recognition </category>
          
      </categories>
      
      
        <tags>
            
            <tag> face_recognition </tag>
            
            <tag> tkinter </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文献图书资源搜索与使用管理</title>
      <link href="wen-xian-tu-shu-zi-yuan-sou-suo-yu-shi-yong-guan-li/"/>
      <url>wen-xian-tu-shu-zi-yuan-sou-suo-yu-shi-yong-guan-li/</url>
      
        <content type="html"><![CDATA[<h2 id="文献引用信息有误"><a href="#文献引用信息有误" class="headerlink" title="文献引用信息有误"></a>文献引用信息有误</h2><blockquote><p>进入Mendeley网站，搜索出错的文献，然后“+Add to library”</p></blockquote><img src="/wen-xian-tu-shu-zi-yuan-sou-suo-yu-shi-yong-guan-li/image-20201012160759194.png" alt="image-20201012160759194" style="zoom:67%;"><blockquote><p>回到Mendeley sync一下，出现该项，但是此时无法打开，如下图将你的论文添加：</p></blockquote><p><img src="/wen-xian-tu-shu-zi-yuan-sou-suo-yu-shi-yong-guan-li/image-20201012160634578.png" alt="image-20201012160634578"></p><h2 id="SCI一区、二区、影响因子？"><a href="#SCI一区、二区、影响因子？" class="headerlink" title="SCI一区、二区、影响因子？"></a>SCI一区、二区、影响因子？</h2><p>一般SCI论文分四个区，一区都是国际顶级期刊，二区次之，三区和四区是一般的SCI期刊，有两种，一种是web of science的JCR（journal citation report）分区，在web of science 搜索论文下面会有按钮显示期刊影响力。另一种是中科院分区，请在高校或中科院内登录<a href="http://www.fenqubiao.com/">http://www.fenqubiao.com</a>。</p><p>影响因子（英文：Impact Factor），简称IF，是汤森路透（Thomson Reuters）出品的期刊引证报告（Journal Citation Reports，JCR）中的一项数据。 即某期刊前两年发表的论文在该报告年份（JCR year）中被引用总次数除以该期刊在这两年内发表的论文总数。这是一个国际上通行的期刊评价指标。影响因子现已成为国际上通用的期刊评价指标，它不仅是一种测度期刊有用性和显示度的指标，而且也是测度期刊的学术水平，乃至论文质量的重要指标。影响因子是一个相对统计量</p><h2 id="知名会议和期刊"><a href="#知名会议和期刊" class="headerlink" title="知名会议和期刊"></a>知名会议和期刊</h2><p>查找会议论文：<a href="https://blog.csdn.net/qq_35091353/article/details/107209512">https://blog.csdn.net/qq_35091353/article/details/107209512</a></p><p><strong>ICCV</strong>:International Conference on Computer Vision</p><p><strong>CVPR</strong>:International Conference on Computer Vision and Pattern Recognition</p><p><strong>ECCV</strong>:Europeon Conference on Computer Vision</p><p><strong>TPAMI</strong>:IEEE TRANSACTIONS ON PATTERN ANALYSIS AND MACHINE INTELLIGENCE</p><p><strong>TIP</strong>:IEEE TRANSACTIONS ON IMAGE PROCESSING</p><p><strong>TSP</strong>: IEEE TRANSACTIONS ON SIGNAL PROCESSING</p><p><strong>ICLR：International Conference on Learning Representations</strong>   顶级会议，大佬背书</p><p><img src="/wen-xian-tu-shu-zi-yuan-sou-suo-yu-shi-yong-guan-li/image-20201119155123687.png" alt="不完整列表"></p><h2 id="图书搜索"><a href="#图书搜索" class="headerlink" title="图书搜索"></a>图书搜索</h2><blockquote><p><strong>虫部落快搜</strong>：<a href="https://search.chongbuluo.com/">https://search.chongbuluo.com/</a></p><p>集合了很多搜索，包括<strong>鸠摩搜书</strong></p><p><strong>Z-Library：</strong><a href="https://1lib.net/">https://1lib.net/</a>   <strong>真的是宝藏</strong></p><p>Library Genesis：<a href="https://libgen.lc/">https://libgen.lc/</a></p></blockquote><h2 id="如何快速有效的读论文？"><a href="#如何快速有效的读论文？" class="headerlink" title="如何快速有效的读论文？"></a>如何快速有效的读论文？</h2><p><strong>进入新方向先看综述！！！</strong></p><h3 id="误区？"><a href="#误区？" class="headerlink" title="误区？"></a>误区？</h3><p><strong>从头到尾恨不得嚼透每个单词</strong>，读完后束之高阁让记忆随风飘摇，<strong>无选择的精读</strong></p><p>读论文和学英语区分开！！！读论文不是来学英语！<strong>那些在阅读中遇到的生单词（学术词汇除外）真的会对通篇的理解形成严重障碍吗？</strong></p><p><strong>只看不记</strong></p><h3 id="如何读一篇论文？"><a href="#如何读一篇论文？" class="headerlink" title="如何读一篇论文？"></a>如何读一篇论文？</h3><img src="/wen-xian-tu-shu-zi-yuan-sou-suo-yu-shi-yong-guan-li/image-20201103091823835.png" alt="论文结构" style="zoom:67%;"><p><img src="/wen-xian-tu-shu-zi-yuan-sou-suo-yu-shi-yong-guan-li/image-20201103092224607.png" alt="是否值得读"></p><p><img src="/wen-xian-tu-shu-zi-yuan-sou-suo-yu-shi-yong-guan-li/image-20201103092352775.png" alt="如何读"></p><p><img src="/wen-xian-tu-shu-zi-yuan-sou-suo-yu-shi-yong-guan-li/image-20201103092602961.png" alt="如何读"> 很多人对于做笔记到底写什么各执一词，这里我觉得每个人在科研的不同阶段对于文章的关注点可能不尽相同，所以很难一言以蔽之。</p><p>比如<strong>初涉科研的小白</strong>，文献阅读能力和论文写作能力比较欠缺，那么可以在<strong>笔记中[用一句话（英文）概括实验、结果、讨论章节中的每一段内容，组成一个阅读笔记]。</strong>这样既可以锻炼英语书写表达能力，也可以逼迫自己[在理解的基础上进行一定量的输出，这是一个加深理解和记忆的过程」。<br>对于<strong>阅读科研文献比较熟练，有一些科研工作经历的人来说</strong>，这个笔记的内容可能是<strong>文中某个新的实验方法、异于其他研究的实验条件、阅读时自己的新想法等等</strong>。精读文献并认真做笔记并不代表读者对于这篇文章的消化过程就此终止，我个人觉得优秀的科研论文、大牛的研究著作依然是常读常新，每位从事科研学习和工作的人在不同的时期都能从中汲取养分。</p><h3 id="总结汇报"><a href="#总结汇报" class="headerlink" title="总结汇报"></a>总结汇报</h3><ul><li>基本信息(标题、作者、作者单位、发表期刊/会议、发表时间)</li><li>核心问题</li><li>主要思路/创新</li><li>存在问题与改进思路</li></ul><h3 id="技巧？"><a href="#技巧？" class="headerlink" title="技巧？"></a>技巧？</h3><p>review论文</p><p>与论文相应的PPT、博客、视频、课程、代码等</p><p>有代码的文章重点看！有代码的话, 一方面便于自己将一些核心思想或者基础知识理解透彻; 另一方面, 将来写文章,做对比试验也方便</p><p>英文论文中，<strong>每段话第一句一般都是主旨句</strong>，剩下内容都是围绕第一句展开（自己写论文时也可以这样，先写一段中心句，下面内容围绕它展开）</p><h2 id="要数据和源码"><a href="#要数据和源码" class="headerlink" title="要数据和源码"></a>要数据和源码</h2><blockquote><p>Xiaodan学姐您好！</p><p>冒昧打扰您，目前我就读于北京邮电大学，研究生一年级，此前一直对于图像美学和图像质量评价非常感兴趣。</p><p>有幸拜读过您的最新的文章 “Beyond Vision: A Multimodal Recurrent Attention Convolutional Neural Network for Unified Image Aesthetic Prediction Tasks”，其工作将多种方法巧妙运用，行文风格清晰，解决了我之前自学时的很多疑问，让我颇为受用，并且诞生出了以您这篇文章为基础进行后续学习和研究的想法。</p><p>因此在开学前的这几个月时间中，我也着手努力复现您这篇文章的架构，并寄希望于复现后，进一步研究学姐在总结部分提出的几个设想，但是因为个人知识的欠缺，在复现结构时遇到了很多困难，难以解决，我身边的同学和老师因为鲜有涉及这方面的研究，也不能给我提供相应的帮助。</p><p>综合上述两点，我想咨询学姐是否方便将源码提供给我这个后辈学习和研究，我必遵守相应的科研道德，以及您的相关要求合理使用这份宝贵的资源。如有搅扰，望您海涵。</p><p>最后，祝学姐工作顺利，科研顺心，生活美满！</p><p>耕耘前辈您好！</p><p>冒昧打扰您，我是就读于北京邮电大学的一名研究生，此前一直对于图像美学和图像质量评价非常感兴趣。</p><p>有幸拜读过您19年的文章 “Theme Aware Aesthetic Distribution Prediction with Full Resolution Photos”，您的工作利用巧妙的方法解决了美学图像多尺寸的输入问题，且行文风格清晰，让我颇为受用。</p><p>在研究生的初期，自己所在项目组一直在开展医学影像相关的工作，但是我个人对这一方面不感兴趣，在与导师交流后，同意我以计算机摄影学和图像美学评价为毕设课题。在看到您的文章过后，文章中的算法我较为熟悉，因此诞生出了以您这篇文章为基础进行后续学习和研究的想法。</p><p>在今年疫情的半年内，我也着手努力复现您这篇文章的架构，但是因为个人知识的欠缺，在复现结构时遇到了很多困难，难以解决，我身边的同学和老师因为鲜有涉及这方面的研究，也不能给我提供相应的帮助。</p><p>综合上述两点，我想咨询前辈是否方便将源码提供给我这个后辈学习和研究，我必遵守相应的科研道德，以及您的相关要求合理引用您的工作，倍加珍惜这份宝贵的资源。如有搅扰，望您海涵。</p><p>最后，祝前辈工作顺利，科研顺心，生活美满！</p></blockquote><h2 id="导出参考文献"><a href="#导出参考文献" class="headerlink" title="导出参考文献"></a>导出参考文献</h2><p>参考该博客：<a href="https://blog.csdn.net/xlcaoyi/article/details/90511973">https://blog.csdn.net/xlcaoyi/article/details/90511973</a></p>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mendeley </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Typora使用问题</title>
      <link href="typora-shi-yong-wen-ti/"/>
      <url>typora-shi-yong-wen-ti/</url>
      
        <content type="html"><![CDATA[<h2 id="无序列表如何退出？"><a href="#无序列表如何退出？" class="headerlink" title="无序列表如何退出？"></a>无序列表如何退出？</h2><p>左上角的选项很迷，可以使用源代码模式退出，还可以按一下退格两下enter退出</p><h2 id="公式块编辑常见命令？"><a href="#公式块编辑常见命令？" class="headerlink" title="公式块编辑常见命令？"></a>公式块编辑常见命令？</h2><blockquote><p>版权声明：本文为博主原创文章，遵循<a href="http://creativecommons.org/licenses/by-sa/4.0/"> CC 4.0 BY-SA </a>版权协议，转载请附上原文出处链接和本声明。</p><p>本文链接：<a href="https://blog.csdn.net/mingzhuo_126/article/details/82722455">https://blog.csdn.net/mingzhuo_126/article/details/82722455</a> </p></blockquote><p><a href="https://blog.csdn.net/u013914471/article/details/82973812">https://blog.csdn.net/u013914471/article/details/82973812</a></p><p>\in 属于 \notin 不属于 \\换行  \{ \} 打大括号 \sim打波浪线</p><p><img src="/typora-shi-yong-wen-ti/image-20201125205741314.png" alt="数学模式重音符"></p><h2 id="emoji表情md编写？"><a href="#emoji表情md编写？" class="headerlink" title="emoji表情md编写？"></a>emoji表情md编写？</h2><p>参考大神博客：<a href="https://sunhwee.com/posts/a927e90e.html">https://sunhwee.com/posts/a927e90e.html</a></p><h3 id="Markdown设置？"><a href="#Markdown设置？" class="headerlink" title="Markdown设置？"></a>Markdown设置？</h3><p>可以在偏好设置的Markdown处设置内联公示、代码行号、公式序号</p><h2 id="括号问题"><a href="#括号问题" class="headerlink" title="括号问题"></a>括号问题</h2><p>只有中文括号可以显示在博客中</p><h2 id="莫名其妙的文件被另一个文件覆盖了？"><a href="#莫名其妙的文件被另一个文件覆盖了？" class="headerlink" title="莫名其妙的文件被另一个文件覆盖了？"></a>莫名其妙的文件被另一个文件覆盖了？</h2>]]></content>
      
      
      <categories>
          
          <category> 软件使用 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> typora </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>颜色恒常性之&lt;&lt;A Multi-Hypothesis Approach to Color Constancy&gt;&gt;</title>
      <link href="yan-se-heng-chang-xing-zhi-mhcc/"/>
      <url>yan-se-heng-chang-xing-zhi-mhcc/</url>
      
        <content type="html"><![CDATA[<h2 id="论文思路"><a href="#论文思路" class="headerlink" title="论文思路"></a>论文思路</h2><p>论文：&lt;&lt;A Multi-Hypothesis Approach to Color Constancy&gt;&gt;</p><h3 id="Title-amp-Abstract-amp-Conclusion"><a href="#Title-amp-Abstract-amp-Conclusion" class="headerlink" title="Title&amp;Abstract&amp;Conclusion"></a>Title&amp;Abstract&amp;Conclusion</h3><blockquote><p>Multi-Hypothesis？</p></blockquote><p><strong>多假设都有什么假设？</strong></p><ol><li>Under the prevalent assumption that the scene is illuminated by a single or dominant light source, the observed pixels of an image are typically modelled using the physical model of Lambertian image formation captured under a trichromatic photosensor:</li><li>we assume that the color of the light and the surface reflectance are independent.</li><li>the function modelling the prior also depends on factors such as the environment (indoor / outdoor), the time of day, ISO etc. However, the size of currently available datasets prevent us from modelling more complex proxies.</li></ol><blockquote><p><strong>Our likelihood estimator</strong> learns to answer <strong>a camera-agnostic question</strong> and thus enables <strong>effective multi-camera training</strong> by disentangling illuminant estimation from the supervised learning task.</p><p>learning from image samples that were <strong>captured by multiple cameras</strong></p></blockquote><p><strong>相机无关和多相机图片训练到底是如何实现的？</strong></p><p>只是这个似然估计器与相机无关，多个相机获得多个数据集，对每个数据集利用KMeans找出候选光源，然后都喂入网络，实现了多相机图片训练</p><h3 id="Figure"><a href="#Figure" class="headerlink" title="Figure"></a>Figure</h3><p><img src="/yan-se-heng-chang-xing-zhi-mhcc/image-20201019104708991.png" alt="Figure1"></p><blockquote><p><strong><u>（d）use an illuminant candidate set per camera</u></strong>. <strong><u>[ r/g ,b/g ]</u></strong></p></blockquote><p><strong>每个摄像机获得一个候选集吗？最后是如何训练的？对于每个摄像机的候选集，是如何选取划分的？</strong></p><p>每个摄像机有自己的一个照片集，对这里的图片进行分类，每个摄像机获得一个候选集。训练应该就是将这些候选集都喂入。</p><p><strong>[r/g,b/g]这个图如何读?</strong></p><p>图上一个点应该是代表一个光源，<strong>为了将三维降成二维？</strong>，显示了光源的分布</p><p><img src="/yan-se-heng-chang-xing-zhi-mhcc/image-20201018164327078.png" alt="pipeline"></p><p><strong>如果现在有一张待还原的照片，如何还原，都要生成n个候选光源吗？怎么生成？</strong></p><p>n个候选光源已经生成好了，现在训练网络是需要不同光源的权重配比不同！所以到时候对于待还原照片，还是相同的过程，用每个候选光源修正图片，然后放入网络，得到权重。</p><h3 id="Introduction"><a href="#Introduction" class="headerlink" title="Introduction"></a>Introduction</h3><p>$$<br>\rho_{k}(X)=\int_{\Omega}E(\lambda)S(\lambda,X)C_{k}(\lambda)d\lambda\quad\quad\quad k\in{R,G,B}<br>$$</p><p><strong>为什么要积分？</strong></p><p>积分是因为比如绿色，打个比方是755~760这个频段的波长共同作用生成的，所以需要进行积分。<br>$$<br>\rho_{k}^E=\int_{\Omega}E(\lambda)C_{k}(\lambda)d\lambda\quad\quad\quad k\in{R,G,B}<br>$$</p><p>The goal of computational CC then becomes estimation of the <u><strong>global illumination color</strong></u>$\rho_k^E$？</p><p><strong>为什么变成了这个形式？</strong></p><p>对于物体成像的颜色，$S(\lambda,X)$表示物体本身的影响，$\rho_k^E$就表示光源的影响。后边我们说的光源就是指$\rho_k^E$整体。</p><blockquote><p>due to the <strong>ill-posed</strong> nature of the problem, <strong>multiple illuminant solutions are often possible with varying probability</strong>.</p></blockquote><p><strong>什么是ill-posed ？</strong></p><p>适定问题是指定解满足下面三个要求的问题：① 解是存在的；② 解是唯一的；③ 解连续依赖于定解条件，即解是稳定的。这三个要求中，只要有一个不满足，则称之为不适定问题</p><blockquote><p>avoid <u><strong>distribution shift</strong></u> and <u><strong>resulting domain gap problems</strong></u> [1, 41, 22], associated with camera specific training, and propose a well-founded strategy to leverage multiple data.</p></blockquote><p><strong>什么是distributin shift&amp;domain gap？</strong></p><p><strong>distribution shift</strong>: <a href="https://zh.d2l.ai/">https://zh.d2l.ai/</a> </p><p><strong>domain gap problem</strong>:<a href="https://zhuanlan.zhihu.com/p/195704051">https://zhuanlan.zhihu.com/p/195704051</a></p><blockquote><p>Principled combination of datasets is of high value for learning based color constancy given the typically small nature of individual color constancy datasets (on the order of only hundreds of images).</p></blockquote><p><strong>这句话在说啥？</strong></p><blockquote><p>We provide <strong><u>a training-free model adaptation strategy for new cameras</u></strong>.</p></blockquote><p><strong>加入一个新的摄像机，如何改进模型？</strong></p><p>新加入一个摄像机，只要这个摄像机的候选光源已知了，就可以直接拿这个网络训练了，所以不需要再重新训练或微调。</p><h3 id="Related-Work"><a href="#Related-Work" class="headerlink" title="Related Work"></a>Related Work</h3><h4 id="Bayesian-framework"><a href="#Bayesian-framework" class="headerlink" title="Bayesian framework"></a>Bayesian framework</h4><blockquote><p> They <strong>model the prior of the illuminant and the surface reflectance as a <u>truncated multivariate normal distribution</u> on the weights of a linear model</strong></p></blockquote><p><strong>什么是truncated multivariate normal distribution on the weights of a linear model?</strong></p><p>截断正态分布：指限制变量x取值范围(scope)的一种分布。例如，限制x取值在0到50之间，即{0&lt;x&lt;50}。</p><blockquote><p>Bayesian works [44, 23], <strong>discretise the illuminant space</strong> and <strong>model the surface reflectance priors</strong> by <u><strong>learning real world histogram frequencies</strong></u>;</p></blockquote><p>通过学习真实世界的直方图频率，来离散化光源空间和对表面反射率进行先验建模。<strong>可以查看它如何学习真实世界的直方图频率应用到肤色定级。</strong></p><blockquote><p>in [44] the prior is modelled as a <strong><u>uniform distribution over a subset of illuminants</u></strong> while [23] uses the <strong><u>empirical distribution of the training illuminants</u></strong>.</p></blockquote><p><strong>对于光源概率44和23有两种想法：直接建模成均匀分布和利用训练光源的经验分布。</strong></p><p>经验分布函数：<a href="https://zh.wikipedia.org/zh-hans/%E7%BB%8F%E9%AA%8C%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0#:~:text=%E7%BB%8F%E9%AA%8C%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0%EF%BC%88%E8%8B%B1%E8%AA%9E%EF%BC%9Aempirical,%E6%A0%B7%E6%9C%AC%E6%89%80%E5%8D%A0%E7%9A%84%E6%AF%94%E4%BE%8B%E3%80%82">https://zh.wikipedia.org/zh-hans/%E7%BB%8F%E9%AA%8C%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0#:~:text=%E7%BB%8F%E9%AA%8C%E5%88%86%E5%B8%83%E5%87%BD%E6%95%B0%EF%BC%88%E8%8B%B1%E8%AA%9E%EF%BC%9Aempirical,%E6%A0%B7%E6%9C%AC%E6%89%80%E5%8D%A0%E7%9A%84%E6%AF%94%E4%BE%8B%E3%80%82</a></p><h4 id="Fully-supervised-methods"><a href="#Fully-supervised-methods" class="headerlink" title="Fully supervised methods"></a>Fully supervised methods</h4><blockquote><p>frame color constancy as a classification problem：CCC and FCCC using a color space that identifies image re-illumination with a histogram shift. </p></blockquote><p><strong>CCC和FCCC待看</strong></p><h4 id="Multi-device-training"><a href="#Multi-device-training" class="headerlink" title="Multi-device training"></a>Multi-device training</h4><blockquote><p> [37] affords <strong>fast adaptation to previously unseen cameras</strong>, and robustness to changes in capture device by leveraging annotated samples across different cameras and datasets in a <strong><u>meta-learning</u></strong> framework</p></blockquote><p><strong>meta-learning?</strong></p><blockquote><p>A recent approach [8], makes an assumption that sRGB images collected from the web are well white balanced, therefore, they apply <strong><u>a simple de-gamma correction</u></strong> to approximate an <strong><u>inverse tone mapping</u></strong> and then find achromatic pixels with a CNN to predict the illuminant. </p></blockquote><p><strong>de-gamma correction？inverse tone mapping？</strong></p><h3 id="Method"><a href="#Method" class="headerlink" title="Method"></a>Method</h3><blockquote><p>Let y = (yr, yg, yb) be a pixel from an input image Y in <strong><u>linear RGB space</u></strong>. </p></blockquote><p><strong>线性RGB空间？</strong></p><p><a href="https://www.cnblogs.com/guanzz/p/7416821.html">https://www.cnblogs.com/guanzz/p/7416821.html</a></p><p>gamma校正将把线性颜色空间转变为非线性空间</p><blockquote><p>We model the global illumination, Eq. (2), with the <strong><u>standard linear model</u></strong> [51] such that each pixel y is the product of the surface reflectance r = (rr, rg, rb) and a global illuminant ? = (?r, ?g, ?b) shared by all pixels such that</p></blockquote><p><strong>标准线性模型？</strong></p><p>可能就是三个函数相乘得到一个线性模型？</p><blockquote><p>we propose to frame the CC problem with a <strong><u>probabilistic generative model</u></strong> with unknown surface re- flectances and illuminant</p></blockquote><p><strong>概率生成模型？</strong></p><p><strong>公式推导</strong></p><p>$$<br>P(l|Y)=\frac{P(Y|l)P(l)}{P(Y)}<br>$$</p><p>$$<br>P(Y|l)=\int_rP(Y|l,R=r)P(R=r)dr<br>$$</p><p>公式(4)利用了全概率公式<br>$$<br>\int_rP(Y|l,R=r)P(R=r)dr=P(R=diag(l)^{-1}Y)<br>$$<br>公式(5),由于$y_k=r_k\cdot l_k\quad\quad k\in R,G,B$ 所以当且仅当$R=diag(l)^{-1}$时，才能生成Y,所以此时$P(Y|l,R=diag(l)^{-1})=1$,$P(Y|l,R=else)=0$,所以只剩下一项$P(R=diag(l)^{-1}Y)$</p><blockquote><p>We highlight that learned affine transformation parameters are training <strong>camera-dependent and provide further discussion</strong> on camera agnostic considerations in Section</p></blockquote><p><strong>为什么这个参数是摄像机依赖的？</strong></p><p>因为$B_l$是光源的先验估计，由公式二，全局光源由光源功率和接收函数决定。所以是摄像机依赖的。</p><blockquote><p>In order to estimate the illuminant  l*, we optimise the quadratic cost (minimum MSE Bayesian estimator), minimised by the mean of the posterior distribution:<br>$$<br>l^*=\int_l l\cdot P(l|Y)dl<br>$$</p></blockquote><p><strong>为什么是这个公式？</strong></p><p>我们现在获得了n个光源$l_0、l_1\cdots l_n$和n个概率$p_0、p_1\cdots p_n$,我们如何确定最优光源$l^*$?该论文就是简单使MSE最小，当$l^*$是期望时MSE最小，如果你忘了为啥了可以列个二次函数求导！</p><blockquote><p>We require <strong>a differentiable method</strong> in order to train our model end-to-end, and therefore the use of <strong>a simple Maximum a Posteriori （MAP）inference strategy is not possible</strong>. Therefore to estimate the illuminant l*, we use the minimum mean square error Bayesian estimator, which is minimised by the posterior mean of l (c.f. Eq. (6))”</p></blockquote><p><strong>为什么MAP不行？</strong></p><p>因为反向传播我们是需要求导的，而如果用极大后验估计求$l^*$，似然是用网络得到的，是没有办法求导的；所以我们需要采取一个办法他不需要对网络那一块求导就能得到$l^*$，所以使用最简单的方法-使MSE最小，$l^*$就是各个候选光源的期望。<br>$$<br>l^*=\sum_{i=1}^n l_i\cdot softmax(log(P(l_i|Y)))\<br>=\frac{1}{\sum e^{log(P(l_i|Y))}}\sum_{i=1}^nl_i\cdot e^{log(P(l_i|Y))}\<br>=\frac{1}{\sum P(l_i|Y)}\sum_{i=1}^nl_i\cdot P(l_i|Y)<br>$$</p><blockquote><p>The resulting vector $l^*$ is l2-normalised.</p></blockquote><p><strong>l2-normalised？</strong></p><p><a href="https://blog.cweihang.io/ml/trick/l2_normalize">https://blog.cweihang.io/ml/trick/l2_normalize</a></p><p>？？？</p><h3 id="Results"><a href="#Results" class="headerlink" title="Results"></a>Results</h3><p><strong>Gehler-Shi</strong> dataset存在非一致真实值的情况 2个摄像机，分别为Canon 1D和Canon 5D 室内室外组合 佳能RAW格式保存，并提供了tiff格式，还提供了颜色检查板的坐标 因为自带程序包含非线性处理，所以使用Dcraw转换为tiff格式，并且只对RGGB的两个G取了平均，没有进行去马赛克，12位</p><p>NUS 8个摄像机</p><p>Cube+  Canon550D 主要室外</p><p>NUS Shi均为3折 用之前工作提供的划分 Cube+没提供，所以用所有的图像训练，用比赛数据集测试，还跟人家的比赛结果比了比</p><p>NUS加了个多摄像机模式 自己弄了个划分</p><p><strong>Trimean？</strong></p><p>三均值<br>$$<br>TM=\frac{Q_1+2Q_2+Q_3}{4}<br>$$<br>Q1,Q3为数据的两个四分位点，Q2为中位数</p><h3 id="Appendix"><a href="#Appendix" class="headerlink" title="Appendix"></a>Appendix</h3><p><strong>1x1 Conv?</strong></p><p>也叫Network in Network,添加了一个非线性运算，可用于压缩信道或增加信道</p><p><img src="/yan-se-heng-chang-xing-zhi-mhcc/image-20201027160655612.png" alt="吴恩达课程"></p><blockquote><p>Towards reproducibility, and fair comparison, our suppplementary material provides the cross validation splits, used in the main paper, for multi-device training</p></blockquote><p><strong>Cross validation？</strong></p><p>交叉验证：<a href="https://zhuanlan.zhihu.com/p/24825503">https://zhuanlan.zhihu.com/p/24825503</a></p><h2 id="个人思路"><a href="#个人思路" class="headerlink" title="个人思路"></a>个人思路</h2><h3 id="创新点"><a href="#创新点" class="headerlink" title="创新点"></a><strong>创新点</strong></h3><ol><li><p>提供了最佳光源的多个可能性</p></li><li><p>采用分类的方法而不是回归</p></li><li><p>设计的网络是摄像机无关的，可以使用多设备数据集进行训练，对于新型设备的泛化性比较好</p></li></ol><h3 id="多假设"><a href="#多假设" class="headerlink" title="多假设"></a>多假设</h3><ol><li>Under the prevalent assumption that the scene is illuminated by a single or dominant light source, the observed pixels of an image are typically modelled using the physical model of Lambertian image formation captured under a trichromatic photosensor:</li><li>we assume that the color of the light and the surface reflectance are independent.</li><li>the function modelling the prior also depends on factors such as the environment (indoor / outdoor), the time of day, ISO etc. However, the size of currently available datasets prevent us from modelling more complex proxies.</li></ol><h3 id="网络架构"><a href="#网络架构" class="headerlink" title="网络架构"></a>网络架构</h3><p><img src="/yan-se-heng-chang-xing-zhi-mhcc/image-20201029093444705.png" alt="朗伯特模型"></p><p>对此公式可以进行简化，原式$=S(X)\int_\Omega E(\lambda)C_k(\lambda)d\lambda\quad k\in {R,G,B}$</p><p><strong>公式简化的两种解释</strong></p><p>1：相机R、G、B光谱敏感函数是<strong>狄拉克δ函数</strong>，就是说，每个相机的光敏R、G、B三通道每个只能感应波长的一个值</p><p>2：RGB的能感知的光谱构成可见光的一个划分,$Sup(Rc)$支撑集表示Rc能感知的光谱。对于每个支撑集，<strong>假设反射率函数与波长无关</strong></p><p>我们对该公式用如下形式表示：$y_k=r_k\cdot l_k \quad k\in{R,G,B}$ </p><p>已知一个参数$y_k$,即<strong>我们已经知道的照片</strong>，求两个参数$r_k,l_k$,分别为<strong>物体对成像的影响</strong>和<strong>光照对成像的影响</strong>。</p><p>已知一个参数，求两个参数，约束过少。</p><p><strong>琅伯特模型经典假设：</strong></p><p>  1：<strong>固定相机拍摄的固定场景物体颜色的改变只能由改变光照实现</strong></p><p>  2：<strong>固有物体反射率图像可以通过过滤光照颜色来实现</strong></p><p>过滤光照颜色即除$l_k$,即$r_k=\frac{y_k}{l_k}$,只要获得$r_k$再乘以标准光照，就能获得白平衡图像。所以我们需要做的就是<strong>估计光照</strong>$l_k$</p><p>曾经困扰过我的是$l_k=E\cdot C_k$，<strong>可以变换乘法的位置吗？</strong>后来明白，<strong>我们实际进行颜色还原时，是对每一个像素点进行处理，那么每一个E和C都是一个标量！所以自然可以变换位置</strong></p><p>之前的<strong>回归方法</strong>，是利用网络直接学习$l_k$,这样提供一个点估计，但是<strong>颜色还原问题本身具有不适定性</strong>，可能有多个$l_k$符合条件,每个$l_k$的概率不同。</p><p>所以作者想的是对于图像数据集利用K_means对光源进行聚类，获得的聚类中心点就是候选的光源，也就是多个可能性，解决了上面回归方法的单个点估计的考量。具体做法见下图:</p><p><img src="/yan-se-heng-chang-xing-zhi-mhcc/image-20201029101605001.png" alt="网络架构"><br>$$<br>P(l|Y)=\frac{P(Y|l)P(l)}{P(Y)}<br>$$</p><p>$$<br>P(Y|l)=\int_rP(Y|l,R=r)P(R=r)dr=P(R=diag(l)^{-1}Y)<br>$$</p><p>第一步变换应用了<strong>全概率公式</strong></p><p><strong>第二步变换</strong>由于$y_k=r_k\cdot l_k\quad\quad k\in R,G,B$ 所以当且仅当$R=diag(l)^{-1}$时，才能生成Y,所以此时$P(Y|l,R=diag(l)^{-1})=1$,$P(Y|l,R=else)=0$,所以只剩下一项$P(R=diag(l)^{-1}Y)$</p><p>所以我们这个<strong>CNN网络</strong>为$f^W$,则$log(P(Y|l))=log(P(R=diag(l)^{-1}Y))=f^W(diag(l)^{-1}Y)$，即每个候选光源是场景光源的概率。</p><p>另外，在实际场景中，<strong>不同候选光源出现的概率</strong>是不同的，即$P(l)$不同,基于此我们添加了两个参数$G_l、B_l$，分别为增益系数和$log(P(l))$<br>$$<br>log(P(l|Y))=Gl\cdot log(P(Y|l))+B_l<br>$$<br>而引入这两个参数会带来问题！</p><p>本来我们的网络是<strong>摄像机无关</strong>的,因为没有$log(P(l))$ ,为什么说摄像机无关呢？</p><p>多个相机获得多个数据集，对每个数据集利用KMeans找出候选光源，然后都喂入网络，实现了多相机图片训练。假设我们现在引入了 一个新的摄像机，并获得一个该摄像机的数据集，我们要做的就是对该摄像机进行K-Means，然后测试时，对于一张图片 ，我们现在修正图片需要做的是之前的加上新的候选光源一起修正分别得到概率就行，不需要重新训练或微调。</p><p>而引入$log(P(l))$,之前我们的公式表明，<strong>全局光源由光源功率和接收函数决定</strong>，这个时候就必然引入了摄像机关联。</p><p>所以如果要多设备训练的话，就不引入这两个参数，这样虽<strong>然降低了灵活性，少了两个学习参数，但是现在可用的数据集变多了，大数据集弥补了</strong>。</p><p>我们现在获得了n个光源$l_0、l_1\cdots l_n$和n个概率$p_0、p_1\cdots p_n$,我们如何确定最优光源$l^*$?</p><p>首先<strong>简单的MAP是不行的</strong>，因为反向传播我们是需要求导的，而如果用极大后验估计求$l^*$，似然是用网络得到的，是没有办法求导的；</p><p>所以我<strong>们需要采取一个办法他不需要对网络那一块求导就能得到</strong>$l^*$，该论文就是利用简单的线性组合获得$l^*$，使MSE最小，当$l^*$是期望时MSE最小，如果你忘了为啥了可以列个二次函数求导！<br>$$<br>l^*=\sum_{i=1}^n l_i\cdot softmax(log(P(l_i|Y)))\<br>=\frac{1}{\sum e^{log(P(l_i|Y))}}\sum_{i=1}^nl_i\cdot e^{log(P(l_i|Y))}\<br>=\frac{1}{\sum P(l_i|Y)}\sum_{i=1}^nl_i\cdot P(l_i|Y)<br>$$<br>上式<strong>使用softmax是使概率归一。</strong></p><p><strong>CNN结构：</strong></p><p><img src="/yan-se-heng-chang-xing-zhi-mhcc/image-20201029112002665.png" alt="Architecture"></p><h3 id="失败案例"><a href="#失败案例" class="headerlink" title="失败案例"></a>失败案例</h3><p><strong>1 GT在光源分布外</strong></p><img src="/yan-se-heng-chang-xing-zhi-mhcc/image-20201029112126449.png" alt="failure-1" style="zoom:50%;"><p>因为是线性内插，分布外的点得不到</p><p><strong>2 打破了单一光源假设</strong></p><img src="/yan-se-heng-chang-xing-zhi-mhcc/image-20201029113004477.png" alt="failure-2" style="zoom:67%;"><p><strong>3 问题的不适定本性</strong></p><img src="/yan-se-heng-chang-xing-zhi-mhcc/image-20201029113057076.png" alt="failure-3" style="zoom: 80%;"><p>学到了看起来非常可信的白平衡图片，认为石头是白的，其实石头是黄的</p>]]></content>
      
      
      <categories>
          
          <category> Color Constancy </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CC/AWB </tag>
            
            <tag> Bayes </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo-git-github博客搭建</title>
      <link href="hexo-git-github-bo-ke-da-jian/"/>
      <url>hexo-git-github-bo-ke-da-jian/</url>
      
        <content type="html"><![CDATA[<blockquote><p>参考：洪卫的博客教程<a href="https://sunhwee.com/posts/6e8839eb.html">https://sunhwee.com/posts/6e8839eb.html</a></p><p>参考：hexo-theme-matery主题<a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E8%8F%9C%E5%8D%95%E5%AF%BC%E8%88%AA%E7%9A%84%E5%90%8D%E7%A7%B0%E8%B7%AF%E5%BE%84url%E5%92%8C%E5%9B%BE%E6%A0%87icon">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md#%E9%85%8D%E7%BD%AE%E5%9F%BA%E6%9C%AC%E8%8F%9C%E5%8D%95%E5%AF%BC%E8%88%AA%E7%9A%84%E5%90%8D%E7%A7%B0%E8%B7%AF%E5%BE%84url%E5%92%8C%E5%9B%BE%E6%A0%87icon</a></p><p>参考：过客～励む的博客<a href="https://yafine-blog.cn/posts/4ab2.html">https://yafine-blog.cn/posts/4ab2.html</a></p><p>参考:大佬的artitalk的教程<a href="https://zhangxiaocai.cn/posts/7404e01a.html">https://zhangxiaocai.cn/posts/7404e01a.html</a></p></blockquote><h2 id="按流程搭建遇到的问题："><a href="#按流程搭建遇到的问题：" class="headerlink" title="按流程搭建遇到的问题："></a>按流程搭建遇到的问题：</h2><h3 id="搭建hexo博客时，到了最后一步，hexo-s后只出现代码，而不是首页？"><a href="#搭建hexo博客时，到了最后一步，hexo-s后只出现代码，而不是首页？" class="headerlink" title="搭建hexo博客时，到了最后一步，hexo s后只出现代码，而不是首页？"></a>搭建hexo博客时，到了最后一步，hexo s后只出现代码，而不是首页？</h3><p><img src="/hexo-git-github-bo-ke-da-jian/image-20201012224004113.png" alt="错误代码"></p><p><strong>在npm install安装依赖时出现了错误</strong></p><p><img src="/hexo-git-github-bo-ke-da-jian/image-20201012224051241.png" alt="错误为第10行"></p><p>仔细查看错误信息，我们不难发现是ejs出现了问题。我们可以先执行以下代码后再继续后续操作。</p><pre><code>npm install ejs@2.7.4 --ignore-scripts</code></pre><p><strong><em>注意：之后所有的Bash命令都在最后一个MyBlog文件夹下操作，也就是你之前安装hexo那个文件夹！</em></strong></p><h3 id="什么是github-io？"><a href="#什么是github-io？" class="headerlink" title="什么是github.io？"></a>什么是github.io？</h3><blockquote><p>官网的一句话来形容 Websites for you and your projects</p></blockquote><h3 id="购买个人域名之后打开失败？"><a href="#购买个人域名之后打开失败？" class="headerlink" title="购买个人域名之后打开失败？"></a>购买个人域名之后打开失败？</h3><blockquote><p>极有可能是你未设置域名解析！</p></blockquote><h3 id="写文章发布文章不生成文件夹及图片无法显示？"><a href="#写文章发布文章不生成文件夹及图片无法显示？" class="headerlink" title="写文章发布文章不生成文件夹及图片无法显示？"></a>写文章发布文章不生成文件夹及图片无法显示？</h3><h4 id="不生成文件夹？"><a href="#不生成文件夹？" class="headerlink" title="不生成文件夹？"></a>不生成文件夹？</h4><p>首先，新建博客一定要用hexo new post命令，不然很多信息识别不出来</p><p>然后将_config.yml文件中的post asset folder设置为true，之后会出现文件夹</p><p><img src="/hexo-git-github-bo-ke-da-jian/image-20201012224940500.png" alt="设置为true"></p><h4 id="图片不显示？"><a href="#图片不显示？" class="headerlink" title="图片不显示？"></a>图片不显示？</h4><p>首先下载依赖</p><pre><code>npm install hexo-asset-image --save</code></pre><p>然后对于typora编辑，偏好设置为：</p><img src="/hexo-git-github-bo-ke-da-jian/image-20201012225346785.png" alt="image-20201012225346785" style="zoom: 80%;"><p>然后图片编写时，使用相对路径，例如：</p><p><img src="/hexo-git-github-bo-ke-da-jian/image-20201012225527582.png" alt="例子"></p><p><strong><em>另外注意：千万不要错误使用转义符’\‘!!!!</em></strong></p><h3 id="数学公式块无法正常显示？"><a href="#数学公式块无法正常显示？" class="headerlink" title="数学公式块无法正常显示？"></a>数学公式块无法正常显示？</h3><blockquote><p>后面配置了主题就可以了！</p><p>但是注意：<strong>数学公式中如果出现了连续两个{，中间一定要加空格！</strong></p></blockquote><h3 id="菜单导航配置在哪？"><a href="#菜单导航配置在哪？" class="headerlink" title="菜单导航配置在哪？"></a>菜单导航配置在哪？</h3><blockquote><p>菜单导航配置在themes/hexo-theme-matery/__config.yml</p></blockquote><h2 id="什么是TOC"><a href="#什么是TOC" class="headerlink" title="什么是TOC?"></a>什么是TOC?</h2><h3 id="什么是RSS订阅？"><a href="#什么是RSS订阅？" class="headerlink" title="什么是RSS订阅？"></a>什么是RSS订阅？</h3><blockquote><p>​        RSS也称为RSS订阅或RSS提要，博客和新闻网站的一个常见做法是联合其内容。Web联合是指来自网站的内容可供其他站点或远程应用程序使用。Web联合的最常用方法是使用称为<strong>ReallySimpleSyndication</strong>的协议。RSS是一种协议，允许网站将其内容或其部分内容提供给其他网站或应用程序。</p></blockquote><h3 id="DaoVoice"><a href="#DaoVoice" class="headerlink" title="DaoVoice?"></a>DaoVoice?</h3><p><img src="/hexo-git-github-bo-ke-da-jian/image-20201013144940429.png" alt="设置"></p><p><img src="/hexo-git-github-bo-ke-da-jian/image-20201013144951426.png" alt="设置"></p><h3 id="新建文章模板修改失败？"><a href="#新建文章模板修改失败？" class="headerlink" title="新建文章模板修改失败？"></a>新建文章模板修改失败？</h3><blockquote><p>莫名其妙post.md上下都变成了两个—，奇怪</p></blockquote><h3 id="修改页脚"><a href="#修改页脚" class="headerlink" title="修改页脚?"></a>修改页脚?</h3><h3 id="修改社交链接？"><a href="#修改社交链接？" class="headerlink" title="修改社交链接？"></a>修改社交链接？</h3><h3 id="不蒜子？不蒜子访问量和人数无法区分问题？"><a href="#不蒜子？不蒜子访问量和人数无法区分问题？" class="headerlink" title="不蒜子？不蒜子访问量和人数无法区分问题？"></a>不蒜子？不蒜子访问量和人数无法区分问题？</h3><blockquote><p>是一个极简网页计数器</p></blockquote><h3 id="添加动漫人物"><a href="#添加动漫人物" class="headerlink" title="添加动漫人物?"></a>添加动漫人物?</h3><blockquote><p>由于一直要安包，不敢继续弄了</p></blockquote><h3 id="gitalk-error-not-found？"><a href="#gitalk-error-not-found？" class="headerlink" title="gitalk error not found？"></a>gitalk error not found？</h3><blockquote><p><del>既有可能是yml的设置错误！</del></p><p><del><strong>owner和admin都填写github用户名</strong>，<strong>repo填我们的博客github仓库名</strong></del></p><p>问题终于解决！</p><img src="/hexo-git-github-bo-ke-da-jian/image-20201018215249728.png" alt="config" style="zoom:80%;"><img src="/hexo-git-github-bo-ke-da-jian/image-20201018215408171.png" alt="outh app" style="zoom: 50%;"></blockquote><h3 id="yml、yaml格式不正确？"><a href="#yml、yaml格式不正确？" class="headerlink" title="yml、yaml格式不正确？"></a>yml、yaml格式不正确？</h3><blockquote><p>使用这个在线校验器校验：<a href="http://www.bejson.com/validators/yaml_editor/">http://www.bejson.com/validators/yaml_editor/</a></p></blockquote><p>教程：<a href="https://www.runoob.com/w3cnote/yaml-intro.html">https://www.runoob.com/w3cnote/yaml-intro.html</a></p><p>缩进不允许使用tab，只允许空格</p><h3 id="gitalk未找到相关issues？"><a href="#gitalk未找到相关issues？" class="headerlink" title="gitalk未找到相关issues？"></a>gitalk未找到相关issues？</h3><p><img src="/hexo-git-github-bo-ke-da-jian/image-20201013183732541.png" alt="URL"></p><p><img src="/hexo-git-github-bo-ke-da-jian/image-20201013183843079.png" alt="回调函数"></p><blockquote><p>一定要<strong>使用https而不是http</strong></p><p>还是不行？？？</p><p>失败！</p></blockquote><h3 id="网站根目录在哪里？"><a href="#网站根目录在哪里？" class="headerlink" title="网站根目录在哪里？"></a>网站根目录在哪里？</h3><p><img src="/hexo-git-github-bo-ke-da-jian/image-20201013200031772.png" alt="网站根目录"></p><h3 id="如何删除文章："><a href="#如何删除文章：" class="headerlink" title="如何删除文章："></a>如何删除文章：</h3><p>先hexo clean，然后在直接删除，如果不hexo clean的话，还是会再生成。</p><h2 id="git学习"><a href="#git学习" class="headerlink" title="git学习:"></a>git学习:</h2><blockquote><p>廖雪峰git教程 <a href="https://www.liaoxuefeng.com/wiki/896043488029600">https://www.liaoxuefeng.com/wiki/896043488029600</a></p></blockquote><p>git add先将文件放到车里，git commit把一车的东西运往其他城市。</p><p>Git的<code>commit id</code>不是1，2，3……递增的数字，而是一个SHA1计算出来的一个非常大的数字，用十六进制表示。为什么<code>commit id</code>需要用这么一大串数字表示呢？因为Git是分布式的版本控制系统，后面我们还要研究多人在同一个版本库里工作，如果大家都用1，2，3……作为版本号，那肯定就冲突了。</p><h2 id="js、ejs学习："><a href="#js、ejs学习：" class="headerlink" title="js、ejs学习："></a>js、ejs学习：</h2><blockquote><p>js:<a href="https://www.runoob.com/js/js-tutorial.html">https://www.runoob.com/js/js-tutorial.html</a></p></blockquote><p>JavaScript 是<strong>脚本语言，浏览器会在读取代码时，逐行地执行脚本代码</strong>。而对于传统编程来说，会在执行前对所有代码进行编译。</p><p>对象最好使用**.**来调用，防止方法调用失败！</p><h2 id="博客编写规范"><a href="#博客编写规范" class="headerlink" title="博客编写规范"></a>博客编写规范</h2><p><strong>不做内容的搬运工！</strong>而是</p><ol><li><strong>论文：记录遇到的问题，只针对问题进行解答</strong></li><li><strong>汇报：对于组会汇报内容进行详细编写</strong></li><li><strong>相应知识点：除了贴教程，最好加一两句自己的心得体会！</strong></li></ol><p>复制的话先清除样式，不然容易出问题</p><h2 id="图片loading不显示？"><a href="#图片loading不显示？" class="headerlink" title="图片loading不显示？"></a>图片loading不显示？</h2><p>gulp加速关掉图片压缩！！！！最好不使用gulp压缩，最好使用hexo-neat</p><h2 id="网页代码显示莫名其妙格式错误？"><a href="#网页代码显示莫名其妙格式错误？" class="headerlink" title="网页代码显示莫名其妙格式错误？"></a>网页代码显示莫名其妙格式错误？</h2><p>语言指定成c++就会出错，指定成c没事，所以还是指定成c，如果还是不行的话可以不指定语言，那样就没有高亮</p>]]></content>
      
      
      <categories>
          
          <category> 博客搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> git </tag>
            
            <tag> ejs </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
